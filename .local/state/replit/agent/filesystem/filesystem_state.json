{"file_contents":{"utils/html_generator.py":{"content":"import markdown\nfrom datetime import datetime\nimport os\nfrom bs4 import BeautifulSoup\nfrom utils.template_manager import TemplateManager\nfrom utils.seo_enhancer import SEOEnhancer\nfrom utils.seo_validator import SEOValidator\n\nclass HtmlGenerator:\n    \"\"\"Generate static HTML from markdown content.\"\"\"\n    \n    def __init__(self, template: str = 'modern', color_scheme: str = 'blue', font_family: str = None, enable_seo: bool = True):\n        \"\"\"Initialize HTML generator with markdown extensions and template options.\"\"\"\n        self.markdown_extensions = [\n            'tables',\n            'codehilite',\n            'fenced_code',\n            'toc',\n            'attr_list'\n        ]\n        self.template = template\n        self.color_scheme = color_scheme\n        self.font_family = font_family\n        self.template_manager = TemplateManager()\n        self.enable_seo = enable_seo\n        self.seo_enhancer = SEOEnhancer() if enable_seo else None\n        self.seo_validator = SEOValidator() if enable_seo else None\n    \n    def generate(self, markdown_content, original_filename, metadata: dict = None):\n        \"\"\"\n        Generate HTML from markdown content.\n        \n        Args:\n            markdown_content: Markdown text content\n            original_filename: Original filename for title\n            metadata: Optional metadata dict with description, keywords, author\n            \n        Returns:\n            str: Complete HTML document (or tuple with SEO report if enabled)\n        \"\"\"\n        try:\n            # Convert markdown to HTML\n            md = markdown.Markdown(extensions=self.markdown_extensions)\n            content_html = md.convert(markdown_content)\n            \n            # Get title from filename\n            title = os.path.splitext(original_filename)[0]\n            \n            # Use template manager for customizable templates\n            html_document = self.template_manager.generate_html(\n                content_html,\n                title,\n                self.template,\n                self.color_scheme,\n                self.font_family\n            )\n            \n            # Apply SEO enhancements if enabled\n            if self.enable_seo and self.seo_enhancer:\n                description = None\n                keywords = None\n                author = None\n                \n                # Extract metadata if provided\n                if metadata:\n                    description = metadata.get('description')\n                    keywords = metadata.get('keywords', [])\n                    author = metadata.get('author')\n                \n                # Generate description from content if not provided\n                if not description:\n                    # Extract first paragraph as description\n                    text = BeautifulSoup(content_html, 'html.parser').get_text()\n                    words = text.split()[:30]\n                    description = ' '.join(words) + ('...' if len(words) >= 30 else '')\n                \n                # Enhance HTML with SEO optimizations\n                html_document = self.seo_enhancer.enhance(\n                    html_document,\n                    title=title,\n                    description=description,\n                    keywords=keywords,\n                    author=author\n                )\n            \n            return html_document\n            \n        except Exception as e:\n            raise Exception(f\"Error generating HTML: {str(e)}\")\n    \n    def validate_seo(self, html_content: str, title: str = None):\n        \"\"\"\n        Validate HTML for SEO best practices.\n        \n        Args:\n            html_content: HTML to validate\n            title: Optional title for context\n            \n        Returns:\n            Dict with SEO score and recommendations\n        \"\"\"\n        if not self.seo_validator:\n            return None\n        \n        return self.seo_validator.validate(html_content, title)\n    \n    def _create_html_document(self, content_html, filename, toc=None):\n        \"\"\"Create complete HTML document with styling.\"\"\"\n        title = os.path.splitext(filename)[0]\n        \n        html_template = f\"\"\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>{title}</title>\n    <style>\n        {self._get_css_styles()}\n    </style>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css\">\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n</head>\n<body>\n    <div class=\"container\">\n        <header class=\"header\">\n            <h1 class=\"site-title\">{title}</h1>\n            <p class=\"generated-info\">Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>\n        </header>\n        \n        {self._generate_toc_html(toc) if toc else ''}\n        \n        <main class=\"content\">\n            {content_html}\n        </main>\n        \n        <footer class=\"footer\">\n            <p>Converted from: {filename}</p>\n            <p>Generated by File to Markdown Converter</p>\n        </footer>\n    </div>\n    \n    <script>\n        hljs.highlightAll();\n        {self._get_javascript()}\n    </script>\n</body>\n</html>\"\"\"\n        \n        return html_template\n    \n    def _generate_toc_html(self, toc):\n        \"\"\"Generate table of contents HTML.\"\"\"\n        if not toc:\n            return \"\"\n        \n        return f\"\"\"\n        <nav class=\"toc\">\n            <h2>Table of Contents</h2>\n            {toc}\n        </nav>\n        \"\"\"\n    \n    def _get_css_styles(self):\n        \"\"\"Get CSS styles for the HTML document.\"\"\"\n        return \"\"\"\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        \n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n            line-height: 1.6;\n            color: #333;\n            background-color: #fff;\n        }\n        \n        .container {\n            max-width: 1000px;\n            margin: 0 auto;\n            padding: 20px;\n        }\n        \n        .header {\n            border-bottom: 2px solid #e1e5e9;\n            margin-bottom: 2rem;\n            padding-bottom: 1rem;\n        }\n        \n        .site-title {\n            color: #2c3e50;\n            margin-bottom: 0.5rem;\n            font-size: 2.5rem;\n        }\n        \n        .generated-info {\n            color: #666;\n            font-size: 0.9rem;\n        }\n        \n        .toc {\n            background-color: #f8f9fa;\n            border: 1px solid #e9ecef;\n            border-radius: 0.25rem;\n            padding: 1rem;\n            margin-bottom: 2rem;\n        }\n        \n        .toc h2 {\n            color: #495057;\n            margin-bottom: 0.5rem;\n            font-size: 1.25rem;\n        }\n        \n        .toc ul {\n            list-style-type: none;\n            padding-left: 0;\n        }\n        \n        .toc li {\n            margin: 0.25rem 0;\n        }\n        \n        .toc a {\n            color: #007bff;\n            text-decoration: none;\n        }\n        \n        .toc a:hover {\n            text-decoration: underline;\n        }\n        \n        .content {\n            margin-bottom: 3rem;\n        }\n        \n        .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 {\n            margin-top: 2rem;\n            margin-bottom: 1rem;\n            color: #2c3e50;\n            line-height: 1.2;\n        }\n        \n        .content h1 {\n            font-size: 2.25rem;\n            border-bottom: 1px solid #eaecef;\n            padding-bottom: 0.3rem;\n        }\n        \n        .content h2 {\n            font-size: 1.75rem;\n            border-bottom: 1px solid #eaecef;\n            padding-bottom: 0.3rem;\n        }\n        \n        .content h3 {\n            font-size: 1.5rem;\n        }\n        \n        .content h4 {\n            font-size: 1.25rem;\n        }\n        \n        .content h5 {\n            font-size: 1.1rem;\n        }\n        \n        .content h6 {\n            font-size: 1rem;\n        }\n        \n        .content p {\n            margin-bottom: 1rem;\n        }\n        \n        .content a {\n            color: #007bff;\n            text-decoration: none;\n        }\n        \n        .content a:hover {\n            text-decoration: underline;\n        }\n        \n        .content ul, .content ol {\n            margin-bottom: 1rem;\n            padding-left: 2rem;\n        }\n        \n        .content li {\n            margin-bottom: 0.25rem;\n        }\n        \n        .content table {\n            border-collapse: collapse;\n            width: 100%;\n            margin-bottom: 1rem;\n            border: 1px solid #dee2e6;\n        }\n        \n        .content th, .content td {\n            padding: 0.75rem;\n            text-align: left;\n            border-bottom: 1px solid #dee2e6;\n        }\n        \n        .content th {\n            background-color: #f8f9fa;\n            font-weight: 600;\n            border-bottom: 2px solid #dee2e6;\n        }\n        \n        .content tr:nth-child(even) {\n            background-color: #f8f9fa;\n        }\n        \n        .content blockquote {\n            border-left: 0.25rem solid #007bff;\n            margin: 1rem 0;\n            padding: 0 1rem;\n            color: #6a737d;\n        }\n        \n        .content code {\n            background-color: #f6f8fa;\n            border-radius: 0.25rem;\n            font-size: 85%;\n            margin: 0;\n            padding: 0.2em 0.4em;\n        }\n        \n        .content pre {\n            background-color: #f6f8fa;\n            border-radius: 0.375rem;\n            font-size: 85%;\n            line-height: 1.45;\n            overflow: auto;\n            padding: 1rem;\n            margin-bottom: 1rem;\n        }\n        \n        .content pre code {\n            background-color: transparent;\n            border: 0;\n            font-size: 100%;\n            margin: 0;\n            padding: 0;\n        }\n        \n        .content img {\n            max-width: 100%;\n            height: auto;\n            margin: 1rem 0;\n        }\n        \n        .footer {\n            border-top: 1px solid #e1e5e9;\n            padding-top: 1rem;\n            text-align: center;\n            color: #666;\n            font-size: 0.9rem;\n        }\n        \n        .footer p {\n            margin-bottom: 0.5rem;\n        }\n        \n        /* Responsive design */\n        @media (max-width: 768px) {\n            .container {\n                padding: 10px;\n            }\n            \n            .site-title {\n                font-size: 2rem;\n            }\n            \n            .content h1 {\n                font-size: 1.75rem;\n            }\n            \n            .content h2 {\n                font-size: 1.5rem;\n            }\n        }\n        \n        /* Print styles */\n        @media print {\n            .container {\n                max-width: none;\n                padding: 0;\n            }\n            \n            .header {\n                border-bottom: 1px solid #000;\n            }\n            \n            .footer {\n                border-top: 1px solid #000;\n            }\n            \n            a {\n                color: #000 !important;\n                text-decoration: none !important;\n            }\n            \n            .toc {\n                break-inside: avoid;\n            }\n        }\n        \"\"\"\n    \n    def _get_javascript(self):\n        \"\"\"Get JavaScript for enhanced functionality.\"\"\"\n        return \"\"\"\n        // Smooth scrolling for anchor links\n        document.querySelectorAll('a[href^=\"#\"]').forEach(anchor => {\n            anchor.addEventListener('click', function (e) {\n                e.preventDefault();\n                const target = document.querySelector(this.getAttribute('href'));\n                if (target) {\n                    target.scrollIntoView({\n                        behavior: 'smooth',\n                        block: 'start'\n                    });\n                }\n            });\n        });\n        \n        // Add copy button to code blocks\n        document.querySelectorAll('pre code').forEach(block => {\n            const button = document.createElement('button');\n            button.textContent = 'Copy';\n            button.style.position = 'absolute';\n            button.style.top = '5px';\n            button.style.right = '5px';\n            button.style.padding = '4px 8px';\n            button.style.fontSize = '12px';\n            button.style.border = '1px solid #ccc';\n            button.style.backgroundColor = '#fff';\n            button.style.cursor = 'pointer';\n            button.style.borderRadius = '3px';\n            \n            const pre = block.parentElement;\n            pre.style.position = 'relative';\n            pre.appendChild(button);\n            \n            button.addEventListener('click', () => {\n                navigator.clipboard.writeText(block.textContent).then(() => {\n                    button.textContent = 'Copied!';\n                    setTimeout(() => {\n                        button.textContent = 'Copy';\n                    }, 2000);\n                });\n            });\n        });\n        \"\"\"\n","size_bytes":13201},"converters/__init__.py":{"content":"\"\"\"\nFile converters package for converting various file formats to markdown.\n\"\"\"\n\nfrom .docx_converter import DocxConverter\nfrom .csv_converter import CsvConverter\nfrom .txt_converter import TxtConverter\nfrom .wxr_converter import WxrConverter\n\n__all__ = ['DocxConverter', 'CsvConverter', 'TxtConverter', 'WxrConverter']\n","size_bytes":321},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"beautifulsoup4>=4.14.2\",\n    \"lxml>=6.0.2\",\n    \"markdown>=3.9\",\n    \"pandas>=2.3.3\",\n    \"python-docx>=1.2.0\",\n    \"pyyaml>=6.0.3\",\n    \"streamlit>=1.50.0\",\n]\n","size_bytes":307},"converters/csv_converter.py":{"content":"import pandas as pd\nimport io\nfrom typing import List\n\nclass CsvConverter:\n    \"\"\"Converter for CSV files to markdown format.\"\"\"\n    \n    def convert(self, file, include_metadata=True):\n        \"\"\"\n        Convert CSV file to markdown.\n        \n        Args:\n            file: Streamlit uploaded file object\n            include_metadata: Whether to include file metadata\n            \n        Returns:\n            str: Markdown content\n        \"\"\"\n        try:\n            # Read CSV file\n            content = file.read()\n            \n            # Try different encodings\n            encodings = ['utf-8', 'latin-1', 'cp1252']\n            df = None\n            \n            for encoding in encodings:\n                try:\n                    csv_content = io.StringIO(content.decode(encoding))\n                    df = pd.read_csv(csv_content)\n                    break\n                except (UnicodeDecodeError, pd.errors.EmptyDataError):\n                    continue\n            \n            if df is None:\n                raise Exception(\"Could not read CSV file with any supported encoding\")\n            \n            markdown_lines = []\n            \n            # Add metadata if requested\n            if include_metadata:\n                markdown_lines.extend(self._extract_metadata(df, file.name))\n                markdown_lines.append(\"\")\n            \n            # Convert DataFrame to markdown table\n            markdown_table = self._dataframe_to_markdown(df)\n            markdown_lines.extend(markdown_table)\n            \n            # Add summary statistics if the data is numeric\n            if self._has_numeric_data(df):\n                markdown_lines.append(\"\")\n                markdown_lines.append(\"## Summary Statistics\")\n                markdown_lines.append(\"\")\n                summary_table = self._create_summary_table(df)\n                markdown_lines.extend(summary_table)\n            \n            return \"\\n\".join(markdown_lines)\n            \n        except Exception as e:\n            raise Exception(f\"Error converting CSV file: {str(e)}\")\n    \n    def _extract_metadata(self, df, filename):\n        \"\"\"Extract CSV metadata.\"\"\"\n        metadata = [\n            \"---\",\n            f\"title: \\\"{filename}\\\"\",\n            f\"source_format: \\\"CSV\\\"\",\n            f\"rows: {len(df)}\",\n            f\"columns: {len(df.columns)}\",\n        ]\n        \n        # Add column information\n        column_types = df.dtypes.to_dict()\n        metadata.append(\"columns:\")\n        for col, dtype in column_types.items():\n            metadata.append(f\"  - {col}: {str(dtype)}\")\n        \n        metadata.append(\"---\")\n        return metadata\n    \n    def _dataframe_to_markdown(self, df):\n        \"\"\"Convert DataFrame to markdown table format.\"\"\"\n        if df.empty:\n            return [\"*No data available*\"]\n        \n        # Limit rows for very large datasets\n        display_df = df.head(1000) if len(df) > 1000 else df\n        \n        markdown_table = []\n        \n        # Create header\n        headers = [str(col) for col in display_df.columns]\n        markdown_table.append(\"| \" + \" | \".join(headers) + \" |\")\n        markdown_table.append(\"| \" + \" | \".join([\"---\"] * len(headers)) + \" |\")\n        \n        # Create data rows\n        for _, row in display_df.iterrows():\n            cells = []\n            for value in row:\n                # Clean cell content for markdown\n                cell_content = str(value) if pd.notna(value) else \"\"\n                # Escape pipe characters\n                cell_content = cell_content.replace(\"|\", \"\\\\|\")\n                # Limit cell length\n                if len(cell_content) > 100:\n                    cell_content = cell_content[:97] + \"...\"\n                cells.append(cell_content)\n            \n            markdown_table.append(\"| \" + \" | \".join(cells) + \" |\")\n        \n        # Add note if data was truncated\n        if len(df) > 1000:\n            markdown_table.append(\"\")\n            markdown_table.append(f\"*Note: Showing first 1000 rows out of {len(df)} total rows.*\")\n        \n        return markdown_table\n    \n    def _has_numeric_data(self, df):\n        \"\"\"Check if DataFrame has numeric columns.\"\"\"\n        return any(df.select_dtypes(include=['number']).columns)\n    \n    def _create_summary_table(self, df):\n        \"\"\"Create summary statistics table for numeric columns.\"\"\"\n        numeric_df = df.select_dtypes(include=['number'])\n        \n        if numeric_df.empty:\n            return []\n        \n        # Get summary statistics\n        summary = numeric_df.describe()\n        \n        markdown_table = []\n        \n        # Create header\n        headers = [\"Statistic\"] + [str(col) for col in summary.columns]\n        markdown_table.append(\"| \" + \" | \".join(headers) + \" |\")\n        markdown_table.append(\"| \" + \" | \".join([\"---\"] * len(headers)) + \" |\")\n        \n        # Create rows for each statistic\n        for stat in summary.index:\n            row_data = [str(stat)]\n            for col in summary.columns:\n                value = summary.loc[stat, col]\n                # Format numbers nicely\n                if pd.isna(value):\n                    formatted_value = \"N/A\"\n                else:\n                    formatted_value = f\"{value:.2f}\" if isinstance(value, float) else str(value)\n                row_data.append(formatted_value)\n            \n            markdown_table.append(\"| \" + \" | \".join(row_data) + \" |\")\n        \n        return markdown_table\n","size_bytes":5460},"converters/wxr_converter.py":{"content":"import xml.etree.ElementTree as ET\nfrom bs4 import BeautifulSoup\nimport re\nfrom datetime import datetime\nfrom typing import List, Dict\n\nclass WxrConverter:\n    \"\"\"Converter for WordPress WXR (export) files to markdown format.\"\"\"\n    \n    def __init__(self):\n        self.image_handler = None\n        self.downloaded_images = {}  # Map: original_url -> local_filename\n    \n    def convert(self, file, include_metadata=True, image_handler=None):\n        \"\"\"\n        Convert WXR file to markdown.\n        \n        Args:\n            file: Streamlit uploaded file object\n            include_metadata: Whether to include post metadata\n            image_handler: Optional ImageHandler instance for downloading images\n            \n        Returns:\n            str: Markdown content\n        \"\"\"\n        try:\n            self.image_handler = image_handler\n            self.downloaded_images = {}\n            \n            # Read and parse XML content\n            content = file.read().decode('utf-8', errors='replace')\n            \n            # Parse the WXR content\n            posts = self._parse_wxr_content(content)\n            \n            markdown_lines = []\n            \n            # Add overall metadata if requested\n            if include_metadata:\n                markdown_lines.extend(self._extract_site_metadata(content, file.name))\n                markdown_lines.append(\"\")\n            \n            # Process each post/page\n            for i, post in enumerate(posts):\n                if i > 0:\n                    markdown_lines.append(\"\\n---\\n\")  # Separator between posts\n                \n                post_markdown = self._convert_post_to_markdown(post, include_metadata)\n                markdown_lines.extend(post_markdown)\n            \n            return \"\\n\".join(markdown_lines)\n            \n        except Exception as e:\n            raise Exception(f\"Error converting WXR file: {str(e)}\")\n    \n    def _parse_wxr_content(self, content):\n        \"\"\"Parse WXR XML content and extract posts.\"\"\"\n        posts = []\n        \n        try:\n            # Clean up the XML content\n            content = self._clean_xml_content(content)\n            \n            # Parse XML\n            root = ET.fromstring(content)\n            \n            # Define namespaces\n            namespaces = {\n                'wp': 'http://wordpress.org/export/1.2/',\n                'content': 'http://purl.org/rss/1.0/modules/content/',\n                'excerpt': 'http://wordpress.org/export/1.2/excerpt/',\n                'dc': 'http://purl.org/dc/elements/1.1/'\n            }\n            \n            # Find all items (posts/pages)\n            items = root.findall('.//item')\n            \n            for item in items:\n                post_data = self._extract_post_data(item, namespaces)\n                if post_data and post_data.get('content'):\n                    posts.append(post_data)\n        \n        except ET.ParseError as e:\n            # If XML parsing fails, try to extract content using regex\n            posts = self._parse_wxr_with_regex(content)\n        \n        return posts\n    \n    def _clean_xml_content(self, content):\n        \"\"\"Clean XML content to handle common issues.\"\"\"\n        # Remove or replace problematic characters\n        content = re.sub(r'[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]', '', content)\n        \n        # Fix common encoding issues\n        content = content.replace('&', '&amp;')\n        content = re.sub(r'&amp;(amp|lt|gt|quot|apos);', r'&\\1;', content)\n        \n        return content\n    \n    def _extract_post_data(self, item, namespaces):\n        \"\"\"Extract post data from XML item.\"\"\"\n        post_data = {}\n        \n        # Basic fields\n        title_elem = item.find('title')\n        post_data['title'] = title_elem.text if title_elem is not None else 'Untitled'\n        \n        link_elem = item.find('link')\n        post_data['link'] = link_elem.text if link_elem is not None else ''\n        \n        # WordPress specific fields\n        post_type_elem = item.find('wp:post_type', namespaces)\n        post_data['post_type'] = post_type_elem.text if post_type_elem is not None else 'post'\n        \n        post_status_elem = item.find('wp:status', namespaces)\n        post_data['status'] = post_status_elem.text if post_status_elem is not None else 'publish'\n        \n        post_date_elem = item.find('wp:post_date', namespaces)\n        post_data['date'] = post_date_elem.text if post_date_elem is not None else ''\n        \n        # Content\n        content_elem = item.find('content:encoded', namespaces)\n        post_data['content'] = content_elem.text if content_elem is not None else ''\n        \n        # Excerpt\n        excerpt_elem = item.find('excerpt:encoded', namespaces)\n        post_data['excerpt'] = excerpt_elem.text if excerpt_elem is not None else ''\n        \n        # Author\n        author_elem = item.find('dc:creator', namespaces)\n        post_data['author'] = author_elem.text if author_elem is not None else ''\n        \n        # Categories and tags\n        post_data['categories'] = []\n        post_data['tags'] = []\n        \n        categories = item.findall('category')\n        for cat in categories:\n            domain = cat.get('domain', '')\n            if domain == 'category':\n                post_data['categories'].append(cat.text)\n            elif domain == 'post_tag':\n                post_data['tags'].append(cat.text)\n        \n        return post_data\n    \n    def _parse_wxr_with_regex(self, content):\n        \"\"\"Fallback method to parse WXR using regex when XML parsing fails.\"\"\"\n        posts = []\n        \n        # Find all items using regex\n        item_pattern = r'<item>(.*?)</item>'\n        items = re.findall(item_pattern, content, re.DOTALL)\n        \n        for item_content in items:\n            post_data = {}\n            \n            # Extract title\n            title_match = re.search(r'<title>(.*?)</title>', item_content, re.DOTALL)\n            post_data['title'] = title_match.group(1) if title_match else 'Untitled'\n            \n            # Extract content\n            content_match = re.search(r'<content:encoded><!\\[CDATA\\[(.*?)\\]\\]></content:encoded>', item_content, re.DOTALL)\n            post_data['content'] = content_match.group(1) if content_match else ''\n            \n            # Extract other fields\n            date_match = re.search(r'<wp:post_date>(.*?)</wp:post_date>', item_content)\n            post_data['date'] = date_match.group(1) if date_match else ''\n            \n            author_match = re.search(r'<dc:creator><!\\[CDATA\\[(.*?)\\]\\]></dc:creator>', item_content)\n            post_data['author'] = author_match.group(1) if author_match else ''\n            \n            if post_data.get('content'):\n                posts.append(post_data)\n        \n        return posts\n    \n    def _extract_site_metadata(self, content, filename):\n        \"\"\"Extract site-level metadata from WXR.\"\"\"\n        metadata = [\n            \"---\",\n            f\"title: \\\"WordPress Export - {filename}\\\"\",\n            f\"source_format: \\\"WXR\\\"\",\n            f\"export_date: \\\"{datetime.now().isoformat()}\\\"\",\n        ]\n        \n        # Try to extract site info\n        site_title_match = re.search(r'<title>(.*?)</title>', content)\n        if site_title_match:\n            metadata.append(f\"site_title: \\\"{site_title_match.group(1)}\\\"\")\n        \n        site_url_match = re.search(r'<link>(.*?)</link>', content)\n        if site_url_match:\n            metadata.append(f\"site_url: \\\"{site_url_match.group(1)}\\\"\")\n        \n        # Count posts\n        post_count = len(re.findall(r'<wp:post_type>post</wp:post_type>', content))\n        page_count = len(re.findall(r'<wp:post_type>page</wp:post_type>', content))\n        \n        metadata.append(f\"posts: {post_count}\")\n        metadata.append(f\"pages: {page_count}\")\n        metadata.append(\"---\")\n        \n        return metadata\n    \n    def _convert_post_to_markdown(self, post, include_metadata=True):\n        \"\"\"Convert a single post to markdown.\"\"\"\n        markdown_lines = []\n        \n        # Add post metadata\n        if include_metadata:\n            markdown_lines.append(\"---\")\n            markdown_lines.append(f\"title: \\\"{post.get('title', 'Untitled')}\\\"\")\n            \n            if post.get('date'):\n                markdown_lines.append(f\"date: \\\"{post['date']}\\\"\")\n            \n            if post.get('author'):\n                markdown_lines.append(f\"author: \\\"{post['author']}\\\"\")\n            \n            if post.get('post_type'):\n                markdown_lines.append(f\"type: \\\"{post['post_type']}\\\"\")\n            \n            if post.get('status'):\n                markdown_lines.append(f\"status: \\\"{post['status']}\\\"\")\n            \n            if post.get('categories'):\n                markdown_lines.append(f\"categories: {post['categories']}\")\n            \n            if post.get('tags'):\n                markdown_lines.append(f\"tags: {post['tags']}\")\n            \n            if post.get('link'):\n                markdown_lines.append(f\"original_url: \\\"{post['link']}\\\"\")\n            \n            markdown_lines.append(\"---\")\n            markdown_lines.append(\"\")\n        \n        # Add title as heading\n        markdown_lines.append(f\"# {post.get('title', 'Untitled')}\")\n        markdown_lines.append(\"\")\n        \n        # Add excerpt if available\n        if post.get('excerpt') and post['excerpt'].strip():\n            excerpt_text = self._html_to_markdown(post['excerpt'])\n            markdown_lines.append(\"*\" + excerpt_text.strip() + \"*\")\n            markdown_lines.append(\"\")\n        \n        # Convert content from HTML to markdown\n        if post.get('content'):\n            content_markdown = self._html_to_markdown(post['content'])\n            markdown_lines.append(content_markdown)\n        \n        return markdown_lines\n    \n    def _html_to_markdown(self, html_content):\n        \"\"\"Convert HTML content to markdown.\"\"\"\n        if not html_content:\n            return \"\"\n        \n        # Use BeautifulSoup to parse HTML\n        soup = BeautifulSoup(html_content, 'html.parser')\n        \n        # Convert common HTML elements to markdown\n        markdown_content = self._convert_html_elements(soup)\n        \n        # Clean up the markdown\n        markdown_content = self._clean_markdown(markdown_content)\n        \n        return markdown_content\n    \n    def _convert_html_elements(self, soup):\n        \"\"\"Convert HTML elements to markdown equivalents.\"\"\"\n        # Convert headers\n        for i in range(1, 7):\n            for heading in soup.find_all(f'h{i}'):\n                heading.replace_with(f\"{'#' * i} {heading.get_text().strip()}\\n\\n\")\n        \n        # Convert paragraphs\n        for p in soup.find_all('p'):\n            p.replace_with(f\"{p.get_text().strip()}\\n\\n\")\n        \n        # Convert links\n        for link in soup.find_all('a'):\n            href = link.get('href', '')\n            text = link.get_text().strip()\n            if href and text:\n                link.replace_with(f\"[{text}]({href})\")\n            else:\n                link.replace_with(text)\n        \n        # Convert images\n        for img in soup.find_all('img'):\n            src = img.get('src', '')\n            alt = img.get('alt', 'Image')\n            if src:\n                # Download image if handler is available\n                local_src = self._download_image_if_needed(src)\n                img.replace_with(f\"![{alt}]({local_src})\\n\\n\")\n        \n        # Convert lists\n        for ul in soup.find_all('ul'):\n            list_items = []\n            for li in ul.find_all('li'):\n                list_items.append(f\"- {li.get_text().strip()}\")\n            ul.replace_with('\\n'.join(list_items) + '\\n\\n')\n        \n        for ol in soup.find_all('ol'):\n            list_items = []\n            for i, li in enumerate(ol.find_all('li'), 1):\n                list_items.append(f\"{i}. {li.get_text().strip()}\")\n            ol.replace_with('\\n'.join(list_items) + '\\n\\n')\n        \n        # Convert code blocks\n        for pre in soup.find_all('pre'):\n            code_content = pre.get_text()\n            pre.replace_with(f\"```\\n{code_content}\\n```\\n\\n\")\n        \n        # Convert inline code\n        for code in soup.find_all('code'):\n            code.replace_with(f\"`{code.get_text()}`\")\n        \n        # Convert bold and italic\n        for strong in soup.find_all(['strong', 'b']):\n            strong.replace_with(f\"**{strong.get_text()}**\")\n        \n        for em in soup.find_all(['em', 'i']):\n            em.replace_with(f\"*{em.get_text()}*\")\n        \n        # Convert blockquotes\n        for blockquote in soup.find_all('blockquote'):\n            quote_lines = blockquote.get_text().strip().split('\\n')\n            quote_markdown = '\\n'.join(f\"> {line}\" for line in quote_lines)\n            blockquote.replace_with(f\"{quote_markdown}\\n\\n\")\n        \n        return soup.get_text()\n    \n    def _clean_markdown(self, content):\n        \"\"\"Clean up markdown content.\"\"\"\n        # Remove excessive whitespace\n        content = re.sub(r'\\n{3,}', '\\n\\n', content)\n        \n        # Remove leading/trailing whitespace\n        content = content.strip()\n        \n        # Fix spacing around headers\n        content = re.sub(r'\\n(#{1,6}\\s+.*?)\\n', r'\\n\\n\\1\\n\\n', content)\n        \n        return content\n    \n    def _download_image_if_needed(self, url):\n        \"\"\"Download an image if handler is available, otherwise return original URL.\"\"\"\n        if not self.image_handler:\n            return url\n        \n        # Check if already downloaded\n        if url in self.downloaded_images:\n            return f\"assets/{self.downloaded_images[url]}\"\n        \n        # Try to download the image\n        result = self.image_handler.download_image(url)\n        if result:\n            image_data, ext = result\n            # Optimize and save\n            optimized_data, ext = self.image_handler.optimize_image(image_data)\n            filename = self.image_handler.save_image(optimized_data, ext, prefix=\"wxr_img\")\n            \n            # Store mapping\n            self.downloaded_images[url] = filename\n            return f\"assets/{filename}\"\n        \n        # If download failed, return original URL\n        return url\n","size_bytes":14207},"utils/frontmatter_generator.py":{"content":"from datetime import datetime\nfrom typing import Dict, Any, List\nimport re\nimport yaml\n\nclass FrontmatterGenerator:\n    \"\"\"Generate frontmatter for various static site generators.\"\"\"\n    \n    def __init__(self):\n        self.generators = {\n            'jekyll': self._generate_jekyll_frontmatter,\n            'hugo': self._generate_hugo_frontmatter,\n            'astro': self._generate_astro_frontmatter\n        }\n    \n    def generate(self, ssg_type: str, metadata: Dict[str, Any], filename: str = None) -> str:\n        \"\"\"\n        Generate frontmatter for specified SSG.\n        \n        Args:\n            ssg_type: Type of static site generator (jekyll, hugo, astro)\n            metadata: Metadata dictionary to convert to frontmatter\n            filename: Original filename for fallback title\n            \n        Returns:\n            str: Formatted frontmatter string\n        \"\"\"\n        # Ensure we have at least a title\n        if 'title' not in metadata or not metadata['title']:\n            if filename:\n                metadata['title'] = filename.rsplit('.', 1)[0]\n            else:\n                metadata['title'] = 'Untitled'\n        \n        if ssg_type.lower() in self.generators:\n            return self.generators[ssg_type.lower()](metadata)\n        else:\n            return self._generate_jekyll_frontmatter(metadata)  # Default to Jekyll\n    \n    def _generate_jekyll_frontmatter(self, metadata: Dict[str, Any]) -> str:\n        \"\"\"Generate Jekyll-compatible YAML frontmatter.\"\"\"\n        lines = [\"---\"]\n        \n        # Title (required)\n        if 'title' in metadata:\n            lines.append(f\"title: \\\"{self._escape_yaml(metadata['title'])}\\\"\")\n        \n        # Date\n        if 'date' in metadata:\n            lines.append(f\"date: {self._format_date(metadata['date'])}\")\n        elif 'created' in metadata:\n            lines.append(f\"date: {self._format_date(metadata['created'])}\")\n        else:\n            lines.append(f\"date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S %z')}\")\n        \n        # Author\n        if 'author' in metadata:\n            lines.append(f\"author: \\\"{self._escape_yaml(metadata['author'])}\\\"\")\n        \n        # Categories\n        if 'categories' in metadata and metadata['categories']:\n            if isinstance(metadata['categories'], list):\n                lines.append(\"categories:\")\n                for cat in metadata['categories']:\n                    lines.append(f\"  - {self._escape_yaml(str(cat))}\")\n            else:\n                lines.append(f\"categories: [{self._escape_yaml(str(metadata['categories']))}]\")\n        \n        # Tags\n        if 'tags' in metadata and metadata['tags']:\n            if isinstance(metadata['tags'], list):\n                lines.append(\"tags:\")\n                for tag in metadata['tags']:\n                    lines.append(f\"  - {self._escape_yaml(str(tag))}\")\n            else:\n                lines.append(f\"tags: [{self._escape_yaml(str(metadata['tags']))}]\")\n        \n        # Layout\n        if 'layout' in metadata:\n            lines.append(f\"layout: {metadata['layout']}\")\n        else:\n            lines.append(\"layout: post\")\n        \n        # Permalink\n        if 'permalink' in metadata:\n            lines.append(f\"permalink: {metadata['permalink']}\")\n        \n        # Excerpt\n        if 'excerpt' in metadata:\n            lines.append(f\"excerpt: \\\"{self._escape_yaml(metadata['excerpt'])}\\\"\")\n        \n        # Custom fields\n        for key, value in metadata.items():\n            if key not in ['title', 'date', 'created', 'author', 'categories', 'tags', 'layout', 'permalink', 'excerpt']:\n                if isinstance(value, (list, dict)):\n                    continue  # Skip complex types for now\n                lines.append(f\"{key}: \\\"{self._escape_yaml(str(value))}\\\"\")\n        \n        lines.append(\"---\")\n        return \"\\n\".join(lines)\n    \n    def _generate_hugo_frontmatter(self, metadata: Dict[str, Any]) -> str:\n        \"\"\"Generate Hugo-compatible YAML/TOML frontmatter.\"\"\"\n        lines = [\"---\"]\n        \n        # Title (required)\n        if 'title' in metadata:\n            lines.append(f\"title: \\\"{self._escape_yaml(metadata['title'])}\\\"\")\n        \n        # Date\n        if 'date' in metadata:\n            lines.append(f\"date: {self._format_date(metadata['date'])}\")\n        elif 'created' in metadata:\n            lines.append(f\"date: {self._format_date(metadata['created'])}\")\n        else:\n            lines.append(f\"date: {datetime.now().isoformat()}\")\n        \n        # Draft status\n        if 'status' in metadata:\n            draft = metadata['status'] != 'publish'\n            lines.append(f\"draft: {str(draft).lower()}\")\n        else:\n            lines.append(\"draft: false\")\n        \n        # Author/Authors\n        if 'author' in metadata:\n            lines.append(f\"author: \\\"{self._escape_yaml(metadata['author'])}\\\"\")\n        \n        # Description/Summary\n        if 'excerpt' in metadata:\n            lines.append(f\"description: \\\"{self._escape_yaml(metadata['excerpt'])}\\\"\")\n        elif 'subject' in metadata:\n            lines.append(f\"description: \\\"{self._escape_yaml(metadata['subject'])}\\\"\")\n        \n        # Tags\n        if 'tags' in metadata and metadata['tags']:\n            if isinstance(metadata['tags'], list):\n                lines.append(\"tags:\")\n                for tag in metadata['tags']:\n                    lines.append(f\"  - \\\"{self._escape_yaml(str(tag))}\\\"\")\n            else:\n                lines.append(f\"tags: [\\\"{self._escape_yaml(str(metadata['tags']))}\\\"]\")\n        \n        # Categories\n        if 'categories' in metadata and metadata['categories']:\n            if isinstance(metadata['categories'], list):\n                lines.append(\"categories:\")\n                for cat in metadata['categories']:\n                    lines.append(f\"  - \\\"{self._escape_yaml(str(cat))}\\\"\")\n            else:\n                lines.append(f\"categories: [\\\"{self._escape_yaml(str(metadata['categories']))}\\\"]\")\n        \n        # Slug\n        if 'title' in metadata:\n            slug = self._generate_slug(metadata['title'])\n            lines.append(f\"slug: \\\"{slug}\\\"\")\n        \n        # Weight (for ordering)\n        lines.append(\"weight: 10\")\n        \n        # Custom taxonomies\n        if 'post_type' in metadata and metadata['post_type']:\n            lines.append(f\"type: \\\"{metadata['post_type']}\\\"\")\n        \n        lines.append(\"---\")\n        return \"\\n\".join(lines)\n    \n    def _generate_astro_frontmatter(self, metadata: Dict[str, Any]) -> str:\n        \"\"\"Generate Astro-compatible frontmatter.\"\"\"\n        lines = [\"---\"]\n        \n        # Title (required)\n        if 'title' in metadata:\n            lines.append(f\"title: \\\"{self._escape_yaml(metadata['title'])}\\\"\")\n        \n        # Description\n        if 'excerpt' in metadata:\n            lines.append(f\"description: \\\"{self._escape_yaml(metadata['excerpt'])}\\\"\")\n        elif 'subject' in metadata:\n            lines.append(f\"description: \\\"{self._escape_yaml(metadata['subject'])}\\\"\")\n        \n        # Publish Date\n        if 'date' in metadata:\n            lines.append(f\"pubDate: \\\"{self._format_date(metadata['date'])}\\\"\")\n        elif 'created' in metadata:\n            lines.append(f\"pubDate: \\\"{self._format_date(metadata['created'])}\\\"\")\n        else:\n            lines.append(f\"pubDate: \\\"{datetime.now().strftime('%Y-%m-%d')}\\\"\")\n        \n        # Updated Date\n        if 'modified' in metadata:\n            lines.append(f\"updatedDate: \\\"{self._format_date(metadata['modified'])}\\\"\")\n        \n        # Author\n        if 'author' in metadata:\n            lines.append(f\"author: \\\"{self._escape_yaml(metadata['author'])}\\\"\")\n        \n        # Hero Image (if available)\n        if 'image' in metadata:\n            lines.append(f\"heroImage: \\\"{metadata['image']}\\\"\")\n        \n        # Tags\n        if 'tags' in metadata and metadata['tags']:\n            if isinstance(metadata['tags'], list):\n                tags_str = \", \".join([f\"\\\"{self._escape_yaml(str(t))}\\\"\" for t in metadata['tags']])\n                lines.append(f\"tags: [{tags_str}]\")\n            else:\n                lines.append(f\"tags: [\\\"{self._escape_yaml(str(metadata['tags']))}\\\"]\")\n        \n        # Categories (as additional tags or custom field)\n        if 'categories' in metadata and metadata['categories']:\n            if isinstance(metadata['categories'], list):\n                cats_str = \", \".join([f\"\\\"{self._escape_yaml(str(c))}\\\"\" for c in metadata['categories']])\n                lines.append(f\"categories: [{cats_str}]\")\n            else:\n                lines.append(f\"categories: [\\\"{self._escape_yaml(str(metadata['categories']))}\\\"]\")\n        \n        # Draft status\n        if 'status' in metadata:\n            draft = metadata['status'] != 'publish'\n            lines.append(f\"draft: {str(draft).lower()}\")\n        else:\n            lines.append(\"draft: false\")\n        \n        lines.append(\"---\")\n        return \"\\n\".join(lines)\n    \n    def _escape_yaml(self, text: str) -> str:\n        \"\"\"Escape special characters for YAML.\"\"\"\n        if not isinstance(text, str):\n            text = str(text)\n        # Escape quotes\n        text = text.replace('\"', '\\\\\"')\n        # Remove control characters\n        text = re.sub(r'[\\x00-\\x1f\\x7f]', '', text)\n        return text\n    \n    def _format_date(self, date_value: Any) -> str:\n        \"\"\"Format date value to ISO format.\"\"\"\n        if isinstance(date_value, str):\n            # Check if it's already ISO format\n            if 'T' in date_value or re.match(r'^\\d{4}-\\d{2}-\\d{2}', date_value):\n                return date_value\n            # Return as-is if we can't parse it\n            return date_value\n        elif isinstance(date_value, datetime):\n            return date_value.isoformat()\n        else:\n            return str(date_value)\n    \n    def _generate_slug(self, title: str) -> str:\n        \"\"\"Generate URL-friendly slug from title.\"\"\"\n        slug = title.lower()\n        slug = re.sub(r'[^\\w\\s-]', '', slug)\n        slug = re.sub(r'[\\s_]+', '-', slug)\n        slug = slug.strip('-')\n        return slug\n    \n    def extract_metadata_from_markdown(self, markdown_content: str) -> Dict[str, Any]:\n        \"\"\"Extract existing frontmatter metadata from markdown content.\"\"\"\n        metadata = {}\n        \n        # Check if content has frontmatter\n        if markdown_content.startswith('---'):\n            parts = markdown_content.split('---', 2)\n            if len(parts) >= 3:\n                frontmatter_text = parts[1].strip()\n                try:\n                    # Use proper YAML parsing to handle complex structures\n                    metadata = yaml.safe_load(frontmatter_text)\n                    if not isinstance(metadata, dict):\n                        metadata = {}\n                except yaml.YAMLError:\n                    # Fallback to simple parsing if YAML parsing fails\n                    for line in frontmatter_text.split('\\n'):\n                        if ':' in line and not line.strip().startswith('-'):\n                            key, value = line.split(':', 1)\n                            key = key.strip()\n                            value = value.strip().strip('\"').strip(\"'\")\n                            metadata[key] = value\n        \n        return metadata\n","size_bytes":11305},"converters/txt_converter.py":{"content":"import re\nfrom typing import List\n\nclass TxtConverter:\n    \"\"\"Converter for TXT files to markdown format.\"\"\"\n    \n    def convert(self, file, include_metadata=True):\n        \"\"\"\n        Convert TXT file to markdown.\n        \n        Args:\n            file: Streamlit uploaded file object\n            include_metadata: Whether to include file metadata\n            \n        Returns:\n            str: Markdown content\n        \"\"\"\n        try:\n            # Read file content with different encodings\n            content = self._read_with_encoding(file)\n            \n            markdown_lines = []\n            \n            # Add metadata if requested\n            if include_metadata:\n                markdown_lines.extend(self._extract_metadata(file.name, content))\n                markdown_lines.append(\"\")\n            \n            # Process the content\n            processed_content = self._process_text_content(content)\n            markdown_lines.extend(processed_content)\n            \n            return \"\\n\".join(markdown_lines)\n            \n        except Exception as e:\n            raise Exception(f\"Error converting TXT file: {str(e)}\")\n    \n    def _read_with_encoding(self, file):\n        \"\"\"Read file content trying different encodings.\"\"\"\n        content = file.read()\n        \n        # Try different encodings\n        encodings = ['utf-8', 'latin-1', 'cp1252', 'ascii']\n        \n        for encoding in encodings:\n            try:\n                return content.decode(encoding)\n            except UnicodeDecodeError:\n                continue\n        \n        # If all encodings fail, use utf-8 with error handling\n        return content.decode('utf-8', errors='replace')\n    \n    def _extract_metadata(self, filename, content):\n        \"\"\"Extract text file metadata.\"\"\"\n        lines = content.split('\\n')\n        word_count = len(content.split())\n        char_count = len(content)\n        line_count = len(lines)\n        \n        metadata = [\n            \"---\",\n            f\"title: \\\"{filename}\\\"\",\n            f\"source_format: \\\"TXT\\\"\",\n            f\"lines: {line_count}\",\n            f\"words: {word_count}\",\n            f\"characters: {char_count}\",\n        ]\n        \n        # Try to detect if it's a structured format\n        structure_type = self._detect_structure(content)\n        if structure_type:\n            metadata.append(f\"structure: \\\"{structure_type}\\\"\")\n        \n        metadata.append(\"---\")\n        return metadata\n    \n    def _detect_structure(self, content):\n        \"\"\"Detect if the text has any recognizable structure.\"\"\"\n        lines = content.split('\\n')\n        \n        # Check for markdown-like headers\n        header_count = sum(1 for line in lines if re.match(r'^#{1,6}\\s+', line.strip()))\n        if header_count > 0:\n            return \"markdown-like\"\n        \n        # Check for numbered lists\n        numbered_list_count = sum(1 for line in lines if re.match(r'^\\d+\\.\\s+', line.strip()))\n        if numbered_list_count > 2:\n            return \"numbered-list\"\n        \n        # Check for bullet points\n        bullet_count = sum(1 for line in lines if re.match(r'^[-*+]\\s+', line.strip()))\n        if bullet_count > 2:\n            return \"bullet-list\"\n        \n        # Check for email-like format\n        if re.search(r'^(From|To|Subject|Date):', content, re.MULTILINE | re.IGNORECASE):\n            return \"email-like\"\n        \n        # Check for code-like structure\n        if re.search(r'(function|class|def|import|#include)', content, re.IGNORECASE):\n            return \"code-like\"\n        \n        return None\n    \n    def _process_text_content(self, content):\n        \"\"\"Process text content and apply intelligent formatting.\"\"\"\n        lines = content.split('\\n')\n        processed_lines = []\n        \n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            processed_line = self._process_line(line, i, lines)\n            \n            if processed_line is not None:\n                processed_lines.append(processed_line)\n            \n            i += 1\n        \n        return processed_lines\n    \n    def _process_line(self, line, index, all_lines):\n        \"\"\"Process individual line with context.\"\"\"\n        stripped_line = line.strip()\n        \n        # Handle empty lines\n        if not stripped_line:\n            return \"\"\n        \n        # Detect and convert headers (lines followed by ===== or -----)\n        if index < len(all_lines) - 1:\n            next_line = all_lines[index + 1].strip()\n            if re.match(r'^=+$', next_line) and len(next_line) >= len(stripped_line) * 0.7:\n                return f\"# {stripped_line}\"\n            elif re.match(r'^-+$', next_line) and len(next_line) >= len(stripped_line) * 0.7:\n                return f\"## {stripped_line}\"\n        \n        # Skip underline markers (they're handled above)\n        if re.match(r'^[=-]+$', stripped_line):\n            return None\n        \n        # Detect numbered lists\n        if re.match(r'^\\d+\\.\\s+', stripped_line):\n            return stripped_line\n        \n        # Detect bullet points and convert to markdown\n        if re.match(r'^[-*+]\\s+', stripped_line):\n            return stripped_line\n        \n        # Detect potential headers (ALL CAPS lines that are short)\n        if (stripped_line.isupper() and \n            len(stripped_line) < 80 and \n            len(stripped_line.split()) <= 10 and\n            not re.search(r'[.!?]$', stripped_line)):\n            return f\"## {stripped_line.title()}\"\n        \n        # Detect code blocks (lines starting with 4+ spaces or tabs)\n        if re.match(r'^    ', line) or re.match(r'^\\t', line):\n            # Check if we're starting a code block\n            if (index == 0 or \n                not (re.match(r'^    ', all_lines[index-1]) or re.match(r'^\\t', all_lines[index-1]))):\n                return f\"```\\n{line}\"\n            # Check if we're ending a code block\n            elif (index == len(all_lines) - 1 or \n                  not (re.match(r'^    ', all_lines[index+1]) or re.match(r'^\\t', all_lines[index+1]))):\n                return f\"{line}\\n```\"\n            else:\n                return line\n        \n        # Detect URLs and make them links\n        url_pattern = r'(https?://[^\\s]+)'\n        if re.search(url_pattern, stripped_line):\n            processed_line = re.sub(url_pattern, r'[\\1](\\1)', stripped_line)\n            return processed_line\n        \n        # Detect email addresses\n        email_pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        if re.search(email_pattern, stripped_line):\n            processed_line = re.sub(email_pattern, r'[\\g<0>](mailto:\\g<0>)', stripped_line)\n            return processed_line\n        \n        # Regular paragraph\n        return stripped_line\n","size_bytes":6758},"utils/static_site_generator.py":{"content":"import os\nfrom datetime import datetime\nfrom typing import List, Dict, Any\nimport zipfile\nimport io\n\nclass StaticSiteGenerator:\n    \"\"\"Generate a complete static site from converted files.\"\"\"\n    \n    def __init__(self, template: str = 'modern', color_scheme: str = 'blue', font_family: str = None):\n        self.site_name = \"Converted Site\"\n        self.template = template\n        self.color_scheme = color_scheme\n        self.font_family = font_family\n        \n    def generate_site(self, converted_files: List[Dict[str, Any]], site_name: str = None, image_handler=None) -> io.BytesIO:\n        \"\"\"\n        Generate a complete static site with navigation.\n        \n        Args:\n            converted_files: List of converted file data with HTML content\n            site_name: Name of the site\n            image_handler: Optional ImageHandler with extracted images\n            \n        Returns:\n            io.BytesIO: ZIP buffer containing the complete site\n        \"\"\"\n        if site_name:\n            self.site_name = site_name\n        \n        zip_buffer = io.BytesIO()\n        \n        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n            # Generate index page\n            index_html = self._generate_index_page(converted_files)\n            zip_file.writestr('index.html', index_html)\n            \n            # Generate individual pages with navigation\n            for file_data in converted_files:\n                if file_data.get('html_content'):\n                    # Create sanitized filename\n                    page_name = self._sanitize_filename(file_data['original_name'])\n                    page_html = self._generate_page_with_nav(file_data, converted_files)\n                    zip_file.writestr(f'pages/{page_name}.html', page_html)\n            \n            # Generate CSS file\n            css_content = self._generate_site_css()\n            zip_file.writestr('assets/style.css', css_content)\n            \n            # Generate navigation JS\n            js_content = self._generate_site_js()\n            zip_file.writestr('assets/script.js', js_content)\n            \n            # Add images if available\n            if image_handler and hasattr(image_handler, 'images'):\n                images = image_handler.get_all_images()\n                if images:\n                    for image_hash, filename in images.items():\n                        # Get the image data\n                        if hasattr(image_handler, 'image_data') and image_hash in image_handler.image_data:\n                            image_data = image_handler.image_data[image_hash]\n                            zip_file.writestr(f\"assets/{filename}\", image_data)\n            \n            # Generate README\n            readme = self._generate_readme(converted_files)\n            zip_file.writestr('README.md', readme)\n        \n        zip_buffer.seek(0)\n        return zip_buffer\n    \n    def _generate_index_page(self, converted_files: List[Dict[str, Any]]) -> str:\n        \"\"\"Generate the index/home page with links to all documents.\"\"\"\n        file_list_html = []\n        \n        for file_data in converted_files:\n            page_name = self._sanitize_filename(file_data['original_name'])\n            file_type = file_data.get('file_type', 'unknown').upper()\n            \n            file_list_html.append(f'''\n            <div class=\"file-card\">\n                <div class=\"file-icon\">{self._get_file_icon(file_data.get('file_type'))}</div>\n                <div class=\"file-info\">\n                    <h3><a href=\"pages/{page_name}.html\">{file_data['original_name']}</a></h3>\n                    <p class=\"file-meta\">Type: {file_type}</p>\n                </div>\n            </div>\n            ''')\n        \n        html = f'''<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>{self.site_name}</title>\n    <link rel=\"stylesheet\" href=\"assets/style.css\">\n</head>\n<body>\n    <header class=\"site-header\">\n        <div class=\"container\">\n            <h1>{self.site_name}</h1>\n            <p class=\"subtitle\">Converted Documents</p>\n        </div>\n    </header>\n    \n    <main class=\"container\">\n        <section class=\"intro\">\n            <h2>Welcome</h2>\n            <p>This site contains {len(converted_files)} converted document(s). Click on any document below to view it.</p>\n        </section>\n        \n        <section class=\"file-list\">\n            <h2>Documents</h2>\n            <div class=\"file-grid\">\n                {''.join(file_list_html)}\n            </div>\n        </section>\n    </main>\n    \n    <footer class=\"site-footer\">\n        <div class=\"container\">\n            <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>\n            <p>Created with File to Markdown Converter</p>\n        </div>\n    </footer>\n    \n    <script src=\"assets/script.js\"></script>\n</body>\n</html>'''\n        \n        return html\n    \n    def _generate_page_with_nav(self, current_file: Dict[str, Any], all_files: List[Dict[str, Any]]) -> str:\n        \"\"\"Generate a page with navigation to other documents.\"\"\"\n        # The HTML content is already styled with the user's template\n        # We'll inject a navigation sidebar into it\n        content = current_file.get('html_content', '')\n        \n        # Fix image paths - pages are in pages/ subdirectory, so need ../ prefix\n        content = content.replace('src=\"assets/', 'src=\"../assets/')\n        content = content.replace('](assets/', '](../assets/')\n        \n        # Build navigation HTML\n        nav_items = []\n        current_page_name = self._sanitize_filename(current_file['original_name'])\n        \n        for file_data in all_files:\n            page_name = self._sanitize_filename(file_data['original_name'])\n            is_current = page_name == current_page_name\n            active_class = ' class=\"active\"' if is_current else ''\n            nav_items.append(f'<li{active_class}><a href=\"{page_name}.html\">{file_data[\"original_name\"]}</a></li>')\n        \n        nav_html = f'''\n        <div class=\"site-nav-sidebar\">\n            <div class=\"nav-header\">\n                <a href=\"../index.html\" class=\"home-link\">← Home</a>\n                <h3>Documents</h3>\n            </div>\n            <nav class=\"doc-nav\">\n                <ul>\n                    {''.join(nav_items)}\n                </ul>\n            </nav>\n        </div>\n        <style>\n            body {{ display: flex; gap: 2rem; max-width: 1400px; margin: 0 auto; padding: 2rem; }}\n            .site-nav-sidebar {{ width: 250px; background: rgba(255,255,255,0.05); padding: 1.5rem; border-radius: 8px; height: fit-content; position: sticky; top: 20px; flex-shrink: 0; }}\n            .nav-header h3 {{ margin: 1rem 0; }}\n            .nav-header .home-link {{ display: block; margin-bottom: 1rem; opacity: 0.8; }}\n            .doc-nav ul {{ list-style: none; padding: 0; }}\n            .doc-nav li {{ margin-bottom: 0.5rem; }}\n            .doc-nav a {{ display: block; padding: 0.5rem; border-radius: 4px; transition: background 0.2s; }}\n            .doc-nav li.active a {{ font-weight: bold; }}\n            @media (max-width: 768px) {{ body {{ flex-direction: column; }} .site-nav-sidebar {{ width: 100%; position: static; }} }}\n        </style>\n        '''\n        \n        # Inject navigation after opening body tag\n        if '<body>' in content:\n            content = content.replace('<body>', f'<body>{nav_html}', 1)\n        \n        return content\n    \n    def _generate_site_css(self) -> str:\n        \"\"\"Generate CSS for the static site.\"\"\"\n        return '''/* Reset and Base Styles */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    line-height: 1.6;\n    color: #333;\n    background-color: #f5f5f5;\n}\n\n.container {\n    max-width: 1200px;\n    margin: 0 auto;\n    padding: 0 20px;\n}\n\n/* Header Styles */\n.site-header {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 2rem 0;\n    box-shadow: 0 2px 10px rgba(0,0,0,0.1);\n}\n\n.site-header h1 {\n    font-size: 2.5rem;\n    margin-bottom: 0.5rem;\n}\n\n.subtitle {\n    font-size: 1.1rem;\n    opacity: 0.9;\n}\n\n.page-header {\n    background: #667eea;\n    color: white;\n    padding: 1rem 0;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n}\n\n.home-link {\n    color: white;\n    text-decoration: none;\n    display: inline-block;\n    margin-bottom: 0.5rem;\n    opacity: 0.9;\n    transition: opacity 0.2s;\n}\n\n.home-link:hover {\n    opacity: 1;\n}\n\n/* Main Content */\nmain {\n    padding: 3rem 0;\n}\n\n.intro {\n    background: white;\n    padding: 2rem;\n    border-radius: 8px;\n    margin-bottom: 2rem;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.05);\n}\n\n.intro h2 {\n    color: #667eea;\n    margin-bottom: 1rem;\n}\n\n/* File Grid */\n.file-list {\n    margin-top: 2rem;\n}\n\n.file-list h2 {\n    margin-bottom: 1.5rem;\n    color: #333;\n}\n\n.file-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n    gap: 1.5rem;\n}\n\n.file-card {\n    background: white;\n    border-radius: 8px;\n    padding: 1.5rem;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.05);\n    transition: transform 0.2s, box-shadow 0.2s;\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n}\n\n.file-card:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 4px 15px rgba(0,0,0,0.1);\n}\n\n.file-icon {\n    font-size: 2.5rem;\n    width: 60px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    background: #f0f0f0;\n    border-radius: 8px;\n}\n\n.file-info h3 {\n    margin-bottom: 0.5rem;\n}\n\n.file-info h3 a {\n    color: #667eea;\n    text-decoration: none;\n}\n\n.file-info h3 a:hover {\n    text-decoration: underline;\n}\n\n.file-meta {\n    color: #666;\n    font-size: 0.9rem;\n}\n\n/* Page Layout */\n.page-layout {\n    display: flex;\n    gap: 2rem;\n    max-width: 1400px;\n    margin: 2rem auto;\n    padding: 0 20px;\n}\n\n.sidebar {\n    width: 250px;\n    background: white;\n    padding: 1.5rem;\n    border-radius: 8px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.05);\n    height: fit-content;\n    position: sticky;\n    top: 20px;\n}\n\n.sidebar h3 {\n    margin-bottom: 1rem;\n    color: #667eea;\n}\n\n.doc-nav ul {\n    list-style: none;\n}\n\n.doc-nav li {\n    margin-bottom: 0.5rem;\n}\n\n.doc-nav a {\n    color: #333;\n    text-decoration: none;\n    display: block;\n    padding: 0.5rem;\n    border-radius: 4px;\n    transition: background-color 0.2s;\n}\n\n.doc-nav a:hover {\n    background-color: #f0f0f0;\n}\n\n.doc-nav li.active a {\n    background-color: #667eea;\n    color: white;\n}\n\n.page-content {\n    flex: 1;\n    background: white;\n    padding: 2rem;\n    border-radius: 8px;\n    box-shadow: 0 2px 5px rgba(0,0,0,0.05);\n}\n\n/* Article Styles */\narticle h1, article h2, article h3, article h4, article h5, article h6 {\n    margin-top: 1.5rem;\n    margin-bottom: 1rem;\n    color: #2c3e50;\n}\n\narticle h1 {\n    font-size: 2.25rem;\n    border-bottom: 2px solid #eaecef;\n    padding-bottom: 0.5rem;\n}\n\narticle h2 {\n    font-size: 1.75rem;\n    border-bottom: 1px solid #eaecef;\n    padding-bottom: 0.3rem;\n}\n\narticle p {\n    margin-bottom: 1rem;\n}\n\narticle a {\n    color: #667eea;\n    text-decoration: none;\n}\n\narticle a:hover {\n    text-decoration: underline;\n}\n\narticle ul, article ol {\n    margin-bottom: 1rem;\n    padding-left: 2rem;\n}\n\narticle table {\n    border-collapse: collapse;\n    width: 100%;\n    margin-bottom: 1rem;\n}\n\narticle th, article td {\n    padding: 0.75rem;\n    text-align: left;\n    border: 1px solid #dee2e6;\n}\n\narticle th {\n    background-color: #f8f9fa;\n    font-weight: 600;\n}\n\narticle tr:nth-child(even) {\n    background-color: #f8f9fa;\n}\n\narticle code {\n    background-color: #f6f8fa;\n    padding: 0.2em 0.4em;\n    border-radius: 3px;\n    font-size: 85%;\n}\n\narticle pre {\n    background-color: #f6f8fa;\n    padding: 1rem;\n    border-radius: 6px;\n    overflow-x: auto;\n    margin-bottom: 1rem;\n}\n\narticle pre code {\n    background-color: transparent;\n    padding: 0;\n}\n\narticle img {\n    max-width: 100%;\n    height: auto;\n    border-radius: 4px;\n    margin: 1rem 0;\n}\n\narticle blockquote {\n    border-left: 4px solid #667eea;\n    padding-left: 1rem;\n    margin: 1rem 0;\n    color: #6a737d;\n}\n\n/* Footer */\n.site-footer {\n    background: #2c3e50;\n    color: white;\n    padding: 2rem 0;\n    margin-top: 4rem;\n    text-align: center;\n}\n\n.site-footer p {\n    margin-bottom: 0.5rem;\n    opacity: 0.9;\n}\n\n/* Responsive Design */\n@media (max-width: 768px) {\n    .page-layout {\n        flex-direction: column;\n    }\n    \n    .sidebar {\n        width: 100%;\n        position: static;\n    }\n    \n    .file-grid {\n        grid-template-columns: 1fr;\n    }\n    \n    .site-header h1 {\n        font-size: 2rem;\n    }\n}\n\n/* Print Styles */\n@media print {\n    .site-header, .page-header, .sidebar, .site-footer, .home-link {\n        display: none;\n    }\n    \n    .page-content {\n        box-shadow: none;\n        padding: 0;\n    }\n}'''\n    \n    def _generate_site_js(self) -> str:\n        \"\"\"Generate JavaScript for the static site.\"\"\"\n        return '''// Smooth scrolling for anchor links\ndocument.querySelectorAll('a[href^=\"#\"]').forEach(anchor => {\n    anchor.addEventListener('click', function (e) {\n        e.preventDefault();\n        const target = document.querySelector(this.getAttribute('href'));\n        if (target) {\n            target.scrollIntoView({\n                behavior: 'smooth',\n                block: 'start'\n            });\n        }\n    });\n});\n\n// Add copy button to code blocks\ndocument.querySelectorAll('pre code').forEach(block => {\n    const button = document.createElement('button');\n    button.textContent = 'Copy';\n    button.className = 'copy-button';\n    button.style.cssText = `\n        position: absolute;\n        top: 5px;\n        right: 5px;\n        padding: 4px 8px;\n        font-size: 12px;\n        border: 1px solid #ccc;\n        background: #fff;\n        cursor: pointer;\n        border-radius: 3px;\n    `;\n    \n    const pre = block.parentElement;\n    pre.style.position = 'relative';\n    pre.appendChild(button);\n    \n    button.addEventListener('click', () => {\n        navigator.clipboard.writeText(block.textContent).then(() => {\n            button.textContent = 'Copied!';\n            setTimeout(() => {\n                button.textContent = 'Copy';\n            }, 2000);\n        });\n    });\n});\n\n// Initialize\ndocument.addEventListener('DOMContentLoaded', function() {\n    console.log('Static site loaded successfully');\n});'''\n    \n    def _generate_readme(self, converted_files: List[Dict[str, Any]]) -> str:\n        \"\"\"Generate README for the static site.\"\"\"\n        file_list = '\\n'.join([f\"- {f['original_name']}\" for f in converted_files])\n        \n        return f'''# {self.site_name}\n\nThis is a static website generated from converted documents.\n\n## Contents\n\n{file_list}\n\n## Structure\n\n- `index.html` - Home page with list of all documents\n- `pages/` - Individual document pages with navigation\n- `assets/` - CSS and JavaScript files\n\n## Usage\n\n1. Open `index.html` in a web browser\n2. Click on any document to view it\n3. Use the sidebar navigation to browse between documents\n4. Use the \"Back to Home\" link to return to the index\n\n## Serving the Site\n\nYou can serve this site using any static web server:\n\n### Python\n```bash\npython -m http.server 8000\n```\n\n### Node.js\n```bash\nnpx http-server\n```\n\n### PHP\n```bash\nphp -S localhost:8000\n```\n\nThen open http://localhost:8000 in your browser.\n\n---\n\nGenerated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\nCreated with File to Markdown Converter\n'''\n    \n    def _sanitize_filename(self, filename: str) -> str:\n        \"\"\"Sanitize filename for use in URLs.\"\"\"\n        import re\n        # Remove extension\n        name = os.path.splitext(filename)[0]\n        # Convert to lowercase and replace spaces/special chars with hyphens\n        name = re.sub(r'[^\\w\\s-]', '', name.lower())\n        name = re.sub(r'[-\\s]+', '-', name)\n        return name.strip('-')\n    \n    def _get_file_icon(self, file_type: str) -> str:\n        \"\"\"Get emoji icon for file type.\"\"\"\n        icons = {\n            'docx': '📝',\n            'csv': '📊',\n            'txt': '📄',\n            'wxr': '📰',\n            'md': '📋'\n        }\n        return icons.get(file_type, '📄')\n","size_bytes":16366},"utils/file_utils.py":{"content":"import os\nimport zipfile\nimport io\nfrom datetime import datetime\nfrom typing import List, Dict\n\ndef get_file_extension(filename):\n    \"\"\"Get file extension from filename.\"\"\"\n    return os.path.splitext(filename)[1][1:].lower()\n\ndef create_download_zip(converted_files: List[Dict], output_format: str, image_handler=None):\n    \"\"\"\n    Create a ZIP file containing all converted files.\n    \n    Args:\n        converted_files: List of converted file data\n        output_format: Output format (\"Markdown\", \"HTML\", or \"Both\")\n        image_handler: Optional ImageHandler with extracted images\n        \n    Returns:\n        io.BytesIO: ZIP file buffer\n    \"\"\"\n    zip_buffer = io.BytesIO()\n    \n    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:\n        for file_data in converted_files:\n            base_name = os.path.splitext(file_data['original_name'])[0]\n            \n            # Add markdown file\n            if output_format in [\"Markdown\", \"Both\"]:\n                markdown_filename = f\"{base_name}.md\"\n                zip_file.writestr(markdown_filename, file_data['markdown_content'])\n            \n            # Add HTML file\n            if output_format in [\"HTML\", \"Both\"] and file_data['html_content']:\n                html_filename = f\"{base_name}.html\"\n                zip_file.writestr(html_filename, file_data['html_content'])\n            \n            # Add metadata file\n            metadata = create_file_metadata(file_data)\n            metadata_filename = f\"{base_name}_metadata.txt\"\n            zip_file.writestr(metadata_filename, metadata)\n        \n        # Add extracted/downloaded images to assets folder\n        if image_handler and hasattr(image_handler, 'images'):\n            images = image_handler.get_all_images()\n            if images:\n                for image_hash, filename in images.items():\n                    # Get the image data - we need to store it in the handler\n                    if hasattr(image_handler, 'image_data') and image_hash in image_handler.image_data:\n                        image_data = image_handler.image_data[image_hash]\n                        zip_file.writestr(f\"assets/{filename}\", image_data)\n    \n    zip_buffer.seek(0)\n    return zip_buffer\n\ndef create_file_metadata(file_data: Dict) -> str:\n    \"\"\"Create a metadata summary for a converted file.\"\"\"\n    metadata_lines = [\n        f\"File Conversion Metadata\",\n        f\"========================\",\n        f\"\",\n        f\"Original filename: {file_data['original_name']}\",\n        f\"File type: {file_data['file_type'].upper()}\",\n        f\"Conversion date: {datetime.now().isoformat()}\",\n        f\"\",\n        f\"Content statistics:\",\n        f\"- Markdown length: {len(file_data['markdown_content'])} characters\",\n        f\"- Markdown lines: {len(file_data['markdown_content'].splitlines())}\",\n    ]\n    \n    if file_data['html_content']:\n        metadata_lines.extend([\n            f\"- HTML length: {len(file_data['html_content'])} characters\",\n            f\"- HTML lines: {len(file_data['html_content'].splitlines())}\",\n        ])\n    \n    # Add file-specific metadata\n    if file_data['file_type'] == 'csv':\n        # Count tables in markdown\n        table_count = file_data['markdown_content'].count('|')\n        if table_count > 0:\n            metadata_lines.append(f\"- Estimated table cells: {table_count}\")\n    \n    elif file_data['file_type'] == 'docx':\n        # Count headings\n        heading_count = len([line for line in file_data['markdown_content'].splitlines() if line.strip().startswith('#')])\n        metadata_lines.append(f\"- Headings found: {heading_count}\")\n    \n    elif file_data['file_type'] == 'wxr':\n        # Count posts/pages\n        post_separators = file_data['markdown_content'].count('---')\n        metadata_lines.append(f\"- Estimated posts/pages: {max(1, post_separators // 2)}\")\n    \n    return '\\n'.join(metadata_lines)\n\ndef sanitize_filename(filename):\n    \"\"\"Sanitize filename for safe file system usage.\"\"\"\n    # Remove or replace problematic characters\n    import re\n    \n    # Replace problematic characters with underscores\n    filename = re.sub(r'[<>:\"/\\\\|?*]', '_', filename)\n    \n    # Remove control characters\n    filename = re.sub(r'[\\x00-\\x1f\\x7f]', '', filename)\n    \n    # Limit length\n    if len(filename) > 255:\n        name, ext = os.path.splitext(filename)\n        filename = name[:255-len(ext)] + ext\n    \n    # Ensure it doesn't start with a dot (hidden file)\n    if filename.startswith('.'):\n        filename = '_' + filename[1:]\n    \n    return filename\n\ndef format_file_size(size_bytes):\n    \"\"\"Format file size in human readable format.\"\"\"\n    if size_bytes == 0:\n        return \"0 B\"\n    \n    size_names = [\"B\", \"KB\", \"MB\", \"GB\"]\n    i = 0\n    while size_bytes >= 1024 and i < len(size_names) - 1:\n        size_bytes /= 1024.0\n        i += 1\n    \n    return f\"{size_bytes:.1f} {size_names[i]}\"\n\ndef validate_file_type(filename, allowed_extensions):\n    \"\"\"Validate if file type is allowed.\"\"\"\n    ext = get_file_extension(filename)\n    return ext in allowed_extensions\n\ndef clean_text_content(text):\n    \"\"\"Clean text content for better markdown conversion.\"\"\"\n    if not text:\n        return \"\"\n    \n    import re\n    \n    # Normalize line endings\n    text = re.sub(r'\\r\\n?', '\\n', text)\n    \n    # Remove excessive whitespace\n    text = re.sub(r'\\n{3,}', '\\n\\n', text)\n    text = re.sub(r'[ \\t]{2,}', ' ', text)\n    \n    # Remove trailing whitespace from lines\n    text = '\\n'.join(line.rstrip() for line in text.split('\\n'))\n    \n    # Ensure text ends with a newline\n    if text and not text.endswith('\\n'):\n        text += '\\n'\n    \n    return text\n","size_bytes":5650},"converters/docx_converter.py":{"content":"import io\nfrom docx import Document\nfrom docx.shared import Inches\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\nfrom docx.oxml import parse_xml\nimport re\n\nclass DocxConverter:\n    \"\"\"Converter for DOCX files to markdown format.\"\"\"\n    \n    def __init__(self):\n        self.image_handler = None\n        self.extracted_images = {}  # Map: rId -> filename\n    \n    def convert(self, file, include_metadata=True, image_handler=None):\n        \"\"\"\n        Convert DOCX file to markdown.\n        \n        Args:\n            file: Streamlit uploaded file object\n            include_metadata: Whether to include document metadata\n            image_handler: Optional ImageHandler instance for extracting images\n            \n        Returns:\n            str: Markdown content\n        \"\"\"\n        try:\n            self.image_handler = image_handler\n            self.extracted_images = {}\n            \n            # Read the file content\n            file_content = io.BytesIO(file.read())\n            doc = Document(file_content)\n            \n            # Extract images if handler provided\n            if self.image_handler:\n                self._extract_all_images(doc)\n            \n            markdown_lines = []\n            \n            # Add metadata if requested\n            if include_metadata:\n                markdown_lines.extend(self._extract_metadata(doc, file.name))\n                markdown_lines.append(\"\")\n            \n            # Process paragraphs\n            for paragraph in doc.paragraphs:\n                markdown_line = self._convert_paragraph(paragraph)\n                if markdown_line:\n                    markdown_lines.append(markdown_line)\n                    \n                # Check for inline images in the paragraph\n                image_refs = self._extract_paragraph_images(paragraph)\n                for image_ref in image_refs:\n                    if image_ref in self.extracted_images:\n                        markdown_lines.append(f\"\\n![Image](assets/{self.extracted_images[image_ref]})\\n\")\n            \n            # Process tables\n            for table in doc.tables:\n                table_markdown = self._convert_table(table)\n                if table_markdown:\n                    markdown_lines.extend(table_markdown)\n                    markdown_lines.append(\"\")\n            \n            return \"\\n\".join(markdown_lines)\n            \n        except Exception as e:\n            raise Exception(f\"Error converting DOCX file: {str(e)}\")\n    \n    def _extract_metadata(self, doc, filename):\n        \"\"\"Extract document metadata.\"\"\"\n        metadata = [\n            \"---\",\n            f\"title: \\\"{filename}\\\"\",\n            f\"source_format: \\\"DOCX\\\"\",\n        ]\n        \n        try:\n            props = doc.core_properties\n            if props.author:\n                metadata.append(f\"author: \\\"{props.author}\\\"\")\n            if props.created:\n                metadata.append(f\"created: \\\"{props.created.isoformat()}\\\"\")\n            if props.modified:\n                metadata.append(f\"modified: \\\"{props.modified.isoformat()}\\\"\")\n            if props.subject:\n                metadata.append(f\"subject: \\\"{props.subject}\\\"\")\n        except:\n            pass  # Skip metadata if not available\n        \n        metadata.append(\"---\")\n        return metadata\n    \n    def _convert_paragraph(self, paragraph):\n        \"\"\"Convert a paragraph to markdown.\"\"\"\n        if not paragraph.text.strip():\n            return \"\"\n        \n        text = paragraph.text.strip()\n        \n        # Handle different paragraph styles\n        style_name = paragraph.style.name.lower()\n        \n        if 'heading' in style_name:\n            # Extract heading level\n            level = 1\n            if 'heading 1' in style_name:\n                level = 1\n            elif 'heading 2' in style_name:\n                level = 2\n            elif 'heading 3' in style_name:\n                level = 3\n            elif 'heading 4' in style_name:\n                level = 4\n            elif 'heading 5' in style_name:\n                level = 5\n            elif 'heading 6' in style_name:\n                level = 6\n            \n            return f\"{'#' * level} {text}\"\n        \n        # Handle alignment\n        alignment = paragraph.alignment\n        if alignment == WD_PARAGRAPH_ALIGNMENT.CENTER:\n            text = f\"<center>{text}</center>\"\n        elif alignment == WD_PARAGRAPH_ALIGNMENT.RIGHT:\n            text = f\"<div align='right'>{text}</div>\"\n        \n        # Process runs for inline formatting\n        formatted_text = self._process_runs(paragraph.runs)\n        \n        return formatted_text if formatted_text.strip() else text\n    \n    def _process_runs(self, runs):\n        \"\"\"Process runs for inline formatting.\"\"\"\n        result = \"\"\n        \n        for run in runs:\n            text = run.text\n            \n            if run.bold and run.italic:\n                text = f\"***{text}***\"\n            elif run.bold:\n                text = f\"**{text}**\"\n            elif run.italic:\n                text = f\"*{text}*\"\n            \n            if run.underline:\n                text = f\"<u>{text}</u>\"\n            \n            result += text\n        \n        return result\n    \n    def _convert_table(self, table):\n        \"\"\"Convert a table to markdown format.\"\"\"\n        if not table.rows:\n            return []\n        \n        markdown_table = []\n        \n        # Process header row\n        header_row = table.rows[0]\n        header_cells = [cell.text.strip() for cell in header_row.cells]\n        \n        if any(header_cells):  # Only create table if there's content\n            # Create header\n            markdown_table.append(\"| \" + \" | \".join(header_cells) + \" |\")\n            markdown_table.append(\"| \" + \" | \".join([\"---\"] * len(header_cells)) + \" |\")\n            \n            # Process data rows\n            for row in table.rows[1:]:\n                cells = [cell.text.strip() for cell in row.cells]\n                if any(cells):  # Only add row if there's content\n                    markdown_table.append(\"| \" + \" | \".join(cells) + \" |\")\n        \n        return markdown_table\n    \n    def _extract_all_images(self, doc):\n        \"\"\"Extract all images from the document.\"\"\"\n        try:\n            from utils.image_handler import ImageHandler\n            \n            for rel in doc.part.rels.values():\n                if \"image\" in rel.target_ref:\n                    image_part = rel.target_part\n                    rId = rel.rId\n                    image_data = image_part.blob\n                    \n                    # Optimize and save the image\n                    optimized_data, ext = self.image_handler.optimize_image(image_data)\n                    filename = self.image_handler.save_image(optimized_data, ext, prefix=\"docx_img\")\n                    \n                    # Store mapping\n                    self.extracted_images[rId] = filename\n                    \n        except Exception as e:\n            print(f\"Warning: Could not extract images: {str(e)}\")\n    \n    def _extract_paragraph_images(self, paragraph):\n        \"\"\"Extract image references from a paragraph.\"\"\"\n        image_refs = []\n        \n        try:\n            # Look for drawing elements in the paragraph\n            for run in paragraph.runs:\n                # Check for inline images\n                if 'graphic' in run._element.xml:\n                    # Parse the XML to find image references\n                    for drawing in run._element.findall('.//{http://schemas.openxmlformats.org/wordprocessingml/2006/main}drawing'):\n                        for blip in drawing.findall('.//{http://schemas.openxmlformats.org/drawingml/2006/main}blip'):\n                            embed = blip.get('{http://schemas.openxmlformats.org/officeDocument/2006/relationships}embed')\n                            if embed:\n                                image_refs.append(embed)\n        except Exception as e:\n            pass  # Silently skip if image extraction fails\n        \n        return image_refs\n","size_bytes":8026},"app.py":{"content":"import streamlit as st\nimport io\nimport zipfile\nimport os\nfrom typing import List, Tuple, Dict\nfrom converters.docx_converter import DocxConverter\nfrom converters.csv_converter import CsvConverter\nfrom converters.txt_converter import TxtConverter\nfrom converters.wxr_converter import WxrConverter\nfrom utils.html_generator import HtmlGenerator\nfrom utils.file_utils import get_file_extension, create_download_zip\nfrom utils.frontmatter_generator import FrontmatterGenerator\nfrom utils.static_site_generator import StaticSiteGenerator\nfrom utils.image_handler import ImageHandler\n\n# Initialize converters\nconverters = {\n    'docx': DocxConverter(),\n    'csv': CsvConverter(),\n    'txt': TxtConverter(),\n    'wxr': WxrConverter()\n}\n\ndef main():\n    st.set_page_config(\n        page_title=\"File to Markdown Converter\",\n        page_icon=\"📄\",\n        layout=\"wide\"\n    )\n    \n    st.title(\"📄 File to Markdown Converter\")\n    st.markdown(\"Convert DOCX, CSV, TXT, and WXR files to clean markdown and static HTML\")\n    \n    # Sidebar for options\n    st.sidebar.header(\"Conversion Options\")\n    output_format = st.sidebar.selectbox(\n        \"Output Format\",\n        [\"Markdown\", \"HTML\", \"Both\"]\n    )\n    \n    include_metadata = st.sidebar.checkbox(\"Include metadata\", value=True)\n    \n    # Frontmatter options\n    st.sidebar.subheader(\"Frontmatter Options\")\n    add_frontmatter = st.sidebar.checkbox(\"Add SSG frontmatter\", value=False, help=\"Add frontmatter for static site generators\")\n    ssg_type = None\n    if add_frontmatter:\n        ssg_type = st.sidebar.selectbox(\n            \"Static Site Generator\",\n            [\"Jekyll\", \"Hugo\", \"Astro\"],\n            help=\"Choose your static site generator\"\n        )\n    \n    # HTML Template options\n    st.sidebar.subheader(\"HTML Template & Styling\")\n    html_template = st.sidebar.selectbox(\n        \"Template\",\n        [\"Modern\", \"Minimal\", \"Classic\", \"Dark\"],\n        help=\"Choose HTML template style\"\n    )\n    \n    color_scheme = st.sidebar.selectbox(\n        \"Color Scheme\",\n        [\"Blue\", \"Green\", \"Purple\", \"Orange\", \"Dark\"],\n        help=\"Choose color scheme\"\n    )\n    \n    font_option = st.sidebar.selectbox(\n        \"Font Family\",\n        [\"Default\", \"Sans-serif\", \"Serif\", \"Monospace\"],\n        help=\"Choose font family\"\n    )\n    \n    font_family = None\n    if font_option == \"Sans-serif\":\n        font_family = '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif'\n    elif font_option == \"Serif\":\n        font_family = 'Georgia, \"Times New Roman\", Times, serif'\n    elif font_option == \"Monospace\":\n        font_family = '\"Courier New\", Courier, monospace'\n    \n    # SEO Options\n    st.sidebar.subheader(\"SEO Optimization\")\n    enable_seo = st.sidebar.checkbox(\"Enable SEO enhancements\", value=True, \n                                      help=\"Automatically enhance HTML with meta tags, Open Graph, structured data, and SEO best practices\")\n    \n    # File upload section\n    st.header(\"Upload Files\")\n    uploaded_files = st.file_uploader(\n        \"Choose files to convert\",\n        type=['docx', 'csv', 'txt', 'wxr'],\n        accept_multiple_files=True,\n        help=\"Supported formats: DOCX, CSV, TXT, WXR\"\n    )\n    \n    if uploaded_files:\n        st.success(f\"Uploaded {len(uploaded_files)} file(s)\")\n        \n        # Process files\n        converted_files = []\n        \n        # Create tabs for different views\n        tab1, tab2, tab3, tab4 = st.tabs([\"📋 File List\", \"👀 Preview\", \"📥 Download\", \"🎯 SEO Report\"])\n        \n        with tab1:\n            st.subheader(\"Files to Convert\")\n            for i, file in enumerate(uploaded_files):\n                col1, col2, col3 = st.columns([3, 1, 1])\n                with col1:\n                    st.write(f\"**{file.name}**\")\n                with col2:\n                    st.write(f\"{file.size} bytes\")\n                with col3:\n                    file_ext = get_file_extension(file.name)\n                    st.write(f\".{file_ext}\")\n        \n        # Convert button\n        if st.button(\"🔄 Convert All Files\", type=\"primary\"):\n            progress_bar = st.progress(0)\n            status_text = st.empty()\n            \n            # Create image handler for extracting/downloading images\n            image_handler = ImageHandler()\n            \n            for i, file in enumerate(uploaded_files):\n                status_text.text(f\"Converting {file.name}...\")\n                \n                try:\n                    file_ext = get_file_extension(file.name)\n                    \n                    if file_ext in converters:\n                        # Convert to markdown with image extraction/downloading\n                        if file_ext in ['docx', 'wxr']:\n                            markdown_content = converters[file_ext].convert(file, include_metadata, image_handler)\n                        else:\n                            markdown_content = converters[file_ext].convert(file, include_metadata)\n                        \n                        # Apply SSG frontmatter if requested\n                        if add_frontmatter and ssg_type:\n                            frontmatter_gen = FrontmatterGenerator()\n                            # Extract existing metadata from markdown\n                            metadata = frontmatter_gen.extract_metadata_from_markdown(markdown_content)\n                            # Generate new frontmatter with filename fallback\n                            new_frontmatter = frontmatter_gen.generate(ssg_type.lower(), metadata, file.name)\n                            # Replace old frontmatter with new one\n                            if markdown_content.startswith('---'):\n                                parts = markdown_content.split('---', 2)\n                                if len(parts) >= 3:\n                                    markdown_content = new_frontmatter + '\\n\\n' + parts[2].strip()\n                            else:\n                                # Add frontmatter to content without it\n                                markdown_content = new_frontmatter + '\\n\\n' + markdown_content\n                        \n                        # Generate HTML if requested\n                        html_content = None\n                        seo_report = None\n                        if output_format in [\"HTML\", \"Both\"]:\n                            html_generator = HtmlGenerator(\n                                template=html_template.lower(),\n                                color_scheme=color_scheme.lower(),\n                                font_family=font_family,\n                                enable_seo=enable_seo\n                            )\n                            html_content = html_generator.generate(markdown_content, file.name)\n                            \n                            # Validate SEO if enabled\n                            if enable_seo:\n                                seo_report = html_generator.validate_seo(html_content, file.name)\n                        \n                        converted_files.append({\n                            'original_name': file.name,\n                            'markdown_content': markdown_content,\n                            'html_content': html_content,\n                            'file_type': file_ext,\n                            'seo_report': seo_report\n                        })\n                        \n                    else:\n                        st.error(f\"Unsupported file type: {file_ext}\")\n                        \n                except Exception as e:\n                    st.error(f\"Error converting {file.name}: {str(e)}\")\n                \n                progress_bar.progress((i + 1) / len(uploaded_files))\n            \n            status_text.text(\"Conversion complete!\")\n            st.session_state.converted_files = converted_files\n            st.session_state.image_handler = image_handler\n        \n        # Display converted files if available\n        if 'converted_files' in st.session_state and st.session_state.converted_files:\n            converted_files = st.session_state.converted_files\n            \n            with tab2:\n                st.subheader(\"Preview Converted Content\")\n                \n                if converted_files:\n                    selected_file = st.selectbox(\n                        \"Select file to preview:\",\n                        [f['original_name'] for f in converted_files]\n                    )\n                    \n                    selected_content = next(\n                        (f for f in converted_files if f['original_name'] == selected_file), \n                        None\n                    )\n                    \n                    if selected_content:\n                        preview_format = st.radio(\"Preview format:\", [\"Markdown\", \"HTML\"], horizontal=True)\n                        \n                        if preview_format == \"Markdown\":\n                            st.markdown(\"**Markdown Content:**\")\n                            st.code(selected_content['markdown_content'], language='markdown')\n                            st.markdown(\"**Rendered Preview:**\")\n                            st.markdown(selected_content['markdown_content'])\n                        else:\n                            if selected_content['html_content']:\n                                st.markdown(\"**HTML Content:**\")\n                                st.code(selected_content['html_content'], language='html')\n                                st.markdown(\"**Rendered Preview:**\")\n                                import streamlit.components.v1 as components\n                                components.html(selected_content['html_content'], height=400)\n                            else:\n                                st.warning(\"HTML content not generated. Select 'HTML' or 'Both' in conversion options.\")\n            \n            with tab3:\n                st.subheader(\"Download Converted Files\")\n                \n                col1, col2 = st.columns(2)\n                \n                with col1:\n                    st.markdown(\"**Individual Downloads:**\")\n                    for file_data in converted_files:\n                        st.markdown(f\"**{file_data['original_name']}**\")\n                        \n                        # Markdown download\n                        if output_format in [\"Markdown\", \"Both\"]:\n                            markdown_filename = f\"{os.path.splitext(file_data['original_name'])[0]}.md\"\n                            st.download_button(\n                                label=\"📄 Download Markdown\",\n                                data=file_data['markdown_content'],\n                                file_name=markdown_filename,\n                                mime='text/markdown',\n                                key=f\"md_{file_data['original_name']}\"\n                            )\n                        \n                        # HTML download\n                        if output_format in [\"HTML\", \"Both\"] and file_data['html_content']:\n                            html_filename = f\"{os.path.splitext(file_data['original_name'])[0]}.html\"\n                            st.download_button(\n                                label=\"🌐 Download HTML\",\n                                data=file_data['html_content'],\n                                file_name=html_filename,\n                                mime='text/html',\n                                key=f\"html_{file_data['original_name']}\"\n                            )\n                        \n                        st.markdown(\"---\")\n                \n                with col2:\n                    st.markdown(\"**Batch Download:**\")\n                    \n                    if st.button(\"📦 Create ZIP Archive\"):\n                        # Get image handler from session state if available\n                        image_handler = st.session_state.get('image_handler', None)\n                        zip_buffer = create_download_zip(converted_files, output_format, image_handler)\n                        \n                        st.download_button(\n                            label=\"📥 Download ZIP Archive\",\n                            data=zip_buffer.getvalue(),\n                            file_name=\"converted_files.zip\",\n                            mime='application/zip'\n                        )\n                    \n                    st.markdown(\"---\")\n                    \n                    st.markdown(\"**Static Site Generator:**\")\n                    \n                    if output_format in [\"HTML\", \"Both\"]:\n                        site_name = st.text_input(\"Site Name:\", value=\"My Converted Documents\", key=\"site_name\")\n                        \n                        if st.button(\"🌐 Generate Static Site\", type=\"primary\"):\n                            # Generate static site with selected template and styling\n                            site_generator = StaticSiteGenerator(\n                                template=html_template.lower(),\n                                color_scheme=color_scheme.lower(),\n                                font_family=font_family\n                            )\n                            # Get image handler from session state if available\n                            image_handler = st.session_state.get('image_handler', None)\n                            site_zip = site_generator.generate_site(converted_files, site_name, image_handler)\n                            \n                            st.success(\"Static site generated successfully!\")\n                            st.download_button(\n                                label=\"📥 Download Static Site\",\n                                data=site_zip.getvalue(),\n                                file_name=f\"{site_name.lower().replace(' ', '_')}_site.zip\",\n                                mime='application/zip',\n                                help=\"Download a complete static website with navigation\"\n                            )\n                    else:\n                        st.info(\"Select 'HTML' or 'Both' output format to generate a static site\")\n            \n            with tab4:\n                st.subheader(\"SEO Analysis Report\")\n                \n                if converted_files:\n                    # Check if any files have SEO reports\n                    files_with_seo = [f for f in converted_files if f.get('seo_report')]\n                    \n                    if files_with_seo:\n                        selected_file = st.selectbox(\n                            \"Select file to view SEO report:\",\n                            [f['original_name'] for f in files_with_seo],\n                            key=\"seo_file_select\"\n                        )\n                        \n                        selected_data = next(\n                            (f for f in files_with_seo if f['original_name'] == selected_file), \n                            None\n                        )\n                        \n                        if selected_data and selected_data.get('seo_report'):\n                            report = selected_data['seo_report']\n                            score = report['score']\n                            \n                            # Display SEO score with color coding\n                            col1, col2, col3 = st.columns([1, 2, 1])\n                            with col1:\n                                st.metric(\"SEO Score\", f\"{score}/100\")\n                            with col2:\n                                from utils.seo_validator import get_seo_grade\n                                grade = get_seo_grade(score)\n                                grade_color = {\n                                    'A': '🟢', 'B': '🟡', 'C': '🟠', 'D': '🔴', 'F': '⚫'\n                                }\n                                st.markdown(f\"### Grade: {grade_color.get(grade, '')} {grade}\")\n                            \n                            st.markdown(\"---\")\n                            \n                            # Display issues, warnings, and successes\n                            col1, col2, col3 = st.columns(3)\n                            \n                            with col1:\n                                st.markdown(\"### ❌ Issues\")\n                                if report['issues']:\n                                    for issue in report['issues']:\n                                        st.error(issue)\n                                else:\n                                    st.success(\"No critical issues!\")\n                            \n                            with col2:\n                                st.markdown(\"### ⚠️ Warnings\")\n                                if report['warnings']:\n                                    for warning in report['warnings']:\n                                        st.warning(warning)\n                                else:\n                                    st.info(\"No warnings\")\n                            \n                            with col3:\n                                st.markdown(\"### ✅ Successes\")\n                                if report['successes']:\n                                    for success in report['successes']:\n                                        st.success(success)\n                            \n                            # Display recommendations\n                            if report['recommendations']:\n                                st.markdown(\"---\")\n                                st.markdown(\"### 💡 Recommendations\")\n                                for i, rec in enumerate(report['recommendations'], 1):\n                                    st.markdown(f\"{i}. {rec}\")\n                    else:\n                        st.info(\"Enable SEO enhancements and generate HTML to see SEO reports\")\n                else:\n                    st.info(\"Convert files first to view SEO reports\")\n    \n    else:\n        st.info(\"👆 Please upload one or more files to get started\")\n        \n        # Show supported formats\n        st.markdown(\"### Supported File Formats\")\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.markdown(\"**DOCX**\\n- Word documents\\n- Preserves formatting\\n- Extracts text and structure\")\n        \n        with col2:\n            st.markdown(\"**CSV**\\n- Comma-separated values\\n- Converts to tables\\n- Maintains data structure\")\n        \n        with col3:\n            st.markdown(\"**TXT**\\n- Plain text files\\n- Preserves line breaks\\n- Basic formatting\")\n        \n        with col4:\n            st.markdown(\"**WXR**\\n- WordPress export\\n- Extracts posts/pages\\n- Preserves metadata\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":18721},"utils/template_manager.py":{"content":"from typing import Dict, Any\nfrom datetime import datetime\n\nclass TemplateManager:\n    \"\"\"Manage HTML templates and styling options.\"\"\"\n    \n    def __init__(self):\n        self.templates = {\n            'modern': self._modern_template,\n            'minimal': self._minimal_template,\n            'classic': self._classic_template,\n            'dark': self._dark_template\n        }\n        \n        self.color_schemes = {\n            'blue': {'primary': '#667eea', 'secondary': '#764ba2', 'text': '#333', 'bg': '#f5f5f5'},\n            'green': {'primary': '#11998e', 'secondary': '#38ef7d', 'text': '#333', 'bg': '#f0f9ff'},\n            'purple': {'primary': '#8e2de2', 'secondary': '#4a00e0', 'text': '#333', 'bg': '#f5f3ff'},\n            'orange': {'primary': '#f46b45', 'secondary': '#eea849', 'text': '#333', 'bg': '#fff7ed'},\n            'dark': {'primary': '#2d3748', 'secondary': '#4a5568', 'text': '#e2e8f0', 'bg': '#1a202c'}\n        }\n    \n    def generate_html(self, content: str, title: str, template: str = 'modern', \n                     color_scheme: str = 'blue', font_family: str = None) -> str:\n        \"\"\"\n        Generate HTML with selected template and styling.\n        \n        Args:\n            content: Markdown-converted HTML content\n            title: Page title\n            template: Template name\n            color_scheme: Color scheme name\n            font_family: Optional custom font family\n            \n        Returns:\n            str: Complete HTML document\n        \"\"\"\n        colors = self.color_schemes.get(color_scheme, self.color_schemes['blue'])\n        \n        if template in self.templates:\n            return self.templates[template](content, title, colors, font_family)\n        else:\n            return self.templates['modern'](content, title, colors, font_family)\n    \n    def _modern_template(self, content: str, title: str, colors: Dict[str, str], font: str = None) -> str:\n        \"\"\"Modern gradient template.\"\"\"\n        font_family = font or '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif'\n        \n        return f'''<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>{title}</title>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css\">\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: {font_family};\n            line-height: 1.6;\n            color: {colors['text']};\n            background: {colors['bg']};\n        }}\n        \n        .container {{\n            max-width: 900px;\n            margin: 0 auto;\n            padding: 0 20px;\n        }}\n        \n        header {{\n            background: linear-gradient(135deg, {colors['primary']} 0%, {colors['secondary']} 100%);\n            color: white;\n            padding: 3rem 0;\n            box-shadow: 0 4px 20px rgba(0,0,0,0.1);\n        }}\n        \n        header h1 {{\n            font-size: 2.5rem;\n            margin-bottom: 0.5rem;\n        }}\n        \n        .meta {{\n            opacity: 0.9;\n            font-size: 0.95rem;\n        }}\n        \n        main {{\n            background: white;\n            margin: 2rem auto;\n            padding: 3rem;\n            border-radius: 12px;\n            box-shadow: 0 2px 15px rgba(0,0,0,0.05);\n        }}\n        \n        h1, h2, h3, h4, h5, h6 {{\n            color: {colors['primary']};\n            margin-top: 2rem;\n            margin-bottom: 1rem;\n        }}\n        \n        h1 {{\n            font-size: 2.5rem;\n            border-bottom: 3px solid {colors['primary']};\n            padding-bottom: 0.5rem;\n        }}\n        \n        h2 {{\n            font-size: 2rem;\n            border-bottom: 2px solid {colors['secondary']};\n            padding-bottom: 0.3rem;\n        }}\n        \n        a {{\n            color: {colors['primary']};\n            text-decoration: none;\n            transition: color 0.2s;\n        }}\n        \n        a:hover {{\n            color: {colors['secondary']};\n            text-decoration: underline;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            margin: 1.5rem 0;\n            box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n        }}\n        \n        th, td {{\n            padding: 0.75rem;\n            text-align: left;\n            border-bottom: 1px solid #e2e8f0;\n        }}\n        \n        th {{\n            background: linear-gradient(135deg, {colors['primary']}, {colors['secondary']});\n            color: white;\n            font-weight: 600;\n        }}\n        \n        tr:hover {{\n            background-color: rgba(102, 126, 234, 0.05);\n        }}\n        \n        code {{\n            background-color: #f7fafc;\n            padding: 0.2em 0.4em;\n            border-radius: 3px;\n            font-size: 85%;\n            border: 1px solid #e2e8f0;\n        }}\n        \n        pre {{\n            background-color: #2d3748;\n            color: #e2e8f0;\n            padding: 1.5rem;\n            border-radius: 8px;\n            overflow-x: auto;\n            margin: 1.5rem 0;\n        }}\n        \n        pre code {{\n            background: transparent;\n            border: none;\n            color: inherit;\n        }}\n        \n        blockquote {{\n            border-left: 4px solid {colors['primary']};\n            padding-left: 1.5rem;\n            margin: 1.5rem 0;\n            font-style: italic;\n            color: #64748b;\n        }}\n        \n        img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 8px;\n            margin: 1.5rem 0;\n            box-shadow: 0 4px 15px rgba(0,0,0,0.1);\n        }}\n        \n        footer {{\n            text-align: center;\n            padding: 2rem 0;\n            color: #64748b;\n            border-top: 1px solid #e2e8f0;\n            margin-top: 3rem;\n        }}\n        \n        @media (max-width: 768px) {{\n            header h1 {{\n                font-size: 2rem;\n            }}\n            main {{\n                padding: 1.5rem;\n                margin: 1rem auto;\n            }}\n        }}\n    </style>\n</head>\n<body>\n    <header>\n        <div class=\"container\">\n            <h1>{title}</h1>\n            <p class=\"meta\">Generated on {datetime.now().strftime('%B %d, %Y')}</p>\n        </div>\n    </header>\n    \n    <main class=\"container\">\n        {content}\n    </main>\n    \n    <footer class=\"container\">\n        <p>Created with File to Markdown Converter</p>\n    </footer>\n    \n    <script>hljs.highlightAll();</script>\n</body>\n</html>'''\n    \n    def _minimal_template(self, content: str, title: str, colors: Dict[str, str], font: str = None) -> str:\n        \"\"\"Clean minimal template.\"\"\"\n        font_family = font or 'Georgia, serif'\n        \n        return f'''<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>{title}</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: {font_family};\n            line-height: 1.8;\n            color: #1a1a1a;\n            background: #ffffff;\n            max-width: 700px;\n            margin: 0 auto;\n            padding: 4rem 2rem;\n        }}\n        \n        h1 {{\n            font-size: 2.5rem;\n            margin-bottom: 0.5rem;\n            font-weight: 700;\n        }}\n        \n        h2, h3, h4, h5, h6 {{\n            margin-top: 2rem;\n            margin-bottom: 1rem;\n        }}\n        \n        p {{\n            margin-bottom: 1rem;\n        }}\n        \n        a {{\n            color: #000;\n            text-decoration: underline;\n        }}\n        \n        code {{\n            background-color: #f5f5f5;\n            padding: 0.2em 0.4em;\n            border-radius: 2px;\n            font-family: 'Courier New', monospace;\n        }}\n        \n        pre {{\n            background-color: #f5f5f5;\n            padding: 1rem;\n            overflow-x: auto;\n            margin: 1rem 0;\n            border-left: 3px solid #000;\n        }}\n        \n        blockquote {{\n            border-left: 3px solid #000;\n            padding-left: 1rem;\n            margin: 1rem 0;\n            font-style: italic;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            margin: 1rem 0;\n        }}\n        \n        th, td {{\n            padding: 0.5rem;\n            text-align: left;\n            border-bottom: 1px solid #ddd;\n        }}\n        \n        th {{\n            font-weight: 600;\n            border-bottom: 2px solid #000;\n        }}\n        \n        img {{\n            max-width: 100%;\n            height: auto;\n            margin: 1rem 0;\n        }}\n        \n        .meta {{\n            color: #666;\n            font-size: 0.9rem;\n            margin-bottom: 2rem;\n        }}\n        \n        footer {{\n            margin-top: 4rem;\n            padding-top: 2rem;\n            border-top: 1px solid #ddd;\n            text-align: center;\n            color: #666;\n            font-size: 0.9rem;\n        }}\n    </style>\n</head>\n<body>\n    <article>\n        <header>\n            <h1>{title}</h1>\n            <p class=\"meta\">{datetime.now().strftime('%B %d, %Y')}</p>\n        </header>\n        \n        {content}\n        \n        <footer>\n            <p>Created with File to Markdown Converter</p>\n        </footer>\n    </article>\n</body>\n</html>'''\n    \n    def _classic_template(self, content: str, title: str, colors: Dict[str, str], font: str = None) -> str:\n        \"\"\"Classic document template.\"\"\"\n        font_family = font or '\"Times New Roman\", Times, serif'\n        \n        return f'''<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>{title}</title>\n    <style>\n        body {{\n            font-family: {font_family};\n            line-height: 1.6;\n            color: #2c3e50;\n            background: #f9f9f9;\n            margin: 0;\n            padding: 2rem;\n        }}\n        \n        .document {{\n            max-width: 800px;\n            margin: 0 auto;\n            background: white;\n            padding: 3rem;\n            box-shadow: 0 0 20px rgba(0,0,0,0.1);\n        }}\n        \n        h1 {{\n            text-align: center;\n            font-size: 2rem;\n            margin-bottom: 0.5rem;\n            text-transform: uppercase;\n            letter-spacing: 2px;\n        }}\n        \n        .date {{\n            text-align: center;\n            color: #7f8c8d;\n            margin-bottom: 2rem;\n            font-style: italic;\n        }}\n        \n        h2, h3, h4 {{\n            margin-top: 2rem;\n            margin-bottom: 1rem;\n        }}\n        \n        p {{\n            text-align: justify;\n            margin-bottom: 1rem;\n        }}\n        \n        a {{\n            color: #3498db;\n            text-decoration: none;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            margin: 1.5rem 0;\n        }}\n        \n        th, td {{\n            padding: 0.75rem;\n            border: 1px solid #bdc3c7;\n        }}\n        \n        th {{\n            background-color: #ecf0f1;\n            font-weight: 600;\n        }}\n        \n        code {{\n            background-color: #ecf0f1;\n            padding: 0.2em 0.4em;\n            border-radius: 3px;\n            font-family: 'Courier New', monospace;\n        }}\n        \n        pre {{\n            background-color: #2c3e50;\n            color: #ecf0f1;\n            padding: 1rem;\n            overflow-x: auto;\n            margin: 1rem 0;\n        }}\n        \n        blockquote {{\n            border-left: 4px solid #3498db;\n            padding-left: 1rem;\n            margin: 1rem 0;\n            font-style: italic;\n            color: #7f8c8d;\n        }}\n        \n        img {{\n            max-width: 100%;\n            height: auto;\n            display: block;\n            margin: 1.5rem auto;\n        }}\n        \n        hr {{\n            border: none;\n            border-top: 2px solid #ecf0f1;\n            margin: 2rem 0;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"document\">\n        <h1>{title}</h1>\n        <p class=\"date\">{datetime.now().strftime('%B %d, %Y')}</p>\n        \n        {content}\n    </div>\n</body>\n</html>'''\n    \n    def _dark_template(self, content: str, title: str, colors: Dict[str, str], font: str = None) -> str:\n        \"\"\"Dark theme template.\"\"\"\n        font_family = font or '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif'\n        \n        return f'''<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>{title}</title>\n    <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: {font_family};\n            line-height: 1.6;\n            color: #e2e8f0;\n            background: #0f172a;\n        }}\n        \n        .container {{\n            max-width: 900px;\n            margin: 0 auto;\n            padding: 0 20px;\n        }}\n        \n        header {{\n            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);\n            color: white;\n            padding: 3rem 0;\n            border-bottom: 2px solid #475569;\n        }}\n        \n        header h1 {{\n            font-size: 2.5rem;\n            margin-bottom: 0.5rem;\n        }}\n        \n        .meta {{\n            opacity: 0.7;\n            font-size: 0.95rem;\n        }}\n        \n        main {{\n            background: #1e293b;\n            margin: 2rem auto;\n            padding: 3rem;\n            border-radius: 12px;\n            border: 1px solid #334155;\n        }}\n        \n        h1, h2, h3, h4, h5, h6 {{\n            color: #38bdf8;\n            margin-top: 2rem;\n            margin-bottom: 1rem;\n        }}\n        \n        h1 {{\n            font-size: 2.5rem;\n            border-bottom: 2px solid #38bdf8;\n            padding-bottom: 0.5rem;\n        }}\n        \n        h2 {{\n            font-size: 2rem;\n            border-bottom: 1px solid #475569;\n            padding-bottom: 0.3rem;\n        }}\n        \n        p {{\n            margin-bottom: 1rem;\n        }}\n        \n        a {{\n            color: #38bdf8;\n            text-decoration: none;\n        }}\n        \n        a:hover {{\n            color: #7dd3fc;\n            text-decoration: underline;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            margin: 1.5rem 0;\n        }}\n        \n        th, td {{\n            padding: 0.75rem;\n            text-align: left;\n            border-bottom: 1px solid #334155;\n        }}\n        \n        th {{\n            background-color: #334155;\n            color: #38bdf8;\n            font-weight: 600;\n        }}\n        \n        tr:hover {{\n            background-color: #334155;\n        }}\n        \n        code {{\n            background-color: #334155;\n            padding: 0.2em 0.4em;\n            border-radius: 3px;\n            font-size: 85%;\n            color: #7dd3fc;\n        }}\n        \n        pre {{\n            background-color: #0f172a;\n            padding: 1.5rem;\n            border-radius: 8px;\n            overflow-x: auto;\n            margin: 1.5rem 0;\n            border: 1px solid #334155;\n        }}\n        \n        pre code {{\n            background: transparent;\n            color: inherit;\n        }}\n        \n        blockquote {{\n            border-left: 4px solid #38bdf8;\n            padding-left: 1.5rem;\n            margin: 1.5rem 0;\n            color: #94a3b8;\n        }}\n        \n        img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 8px;\n            margin: 1.5rem 0;\n        }}\n        \n        footer {{\n            text-align: center;\n            padding: 2rem 0;\n            color: #64748b;\n            border-top: 1px solid #334155;\n            margin-top: 3rem;\n        }}\n        \n        @media (max-width: 768px) {{\n            header h1 {{\n                font-size: 2rem;\n            }}\n            main {{\n                padding: 1.5rem;\n                margin: 1rem auto;\n            }}\n        }}\n    </style>\n</head>\n<body>\n    <header>\n        <div class=\"container\">\n            <h1>{title}</h1>\n            <p class=\"meta\">Generated on {datetime.now().strftime('%B %d, %Y')}</p>\n        </div>\n    </header>\n    \n    <main class=\"container\">\n        {content}\n    </main>\n    \n    <footer class=\"container\">\n        <p>Created with File to Markdown Converter</p>\n    </footer>\n    \n    <script>hljs.highlightAll();</script>\n</body>\n</html>'''\n    \n    def get_available_templates(self):\n        \"\"\"Get list of available template names.\"\"\"\n        return list(self.templates.keys())\n    \n    def get_available_color_schemes(self):\n        \"\"\"Get list of available color schemes.\"\"\"\n        return list(self.color_schemes.keys())\n","size_bytes":17555},"utils/image_handler.py":{"content":"import io\nimport os\nimport base64\nimport hashlib\nimport urllib.request\nimport urllib.error\nfrom typing import Dict, List, Tuple, Optional\nfrom PIL import Image\n\nclass ImageHandler:\n    \"\"\"Handle image extraction, downloading, and conversion.\"\"\"\n    \n    def __init__(self):\n        self.images = {}  # Map: image_hash -> local_filename\n        self.image_data = {}  # Map: image_hash -> binary_data\n        self.image_counter = 0\n        \n    def extract_docx_images(self, doc) -> Dict[str, bytes]:\n        \"\"\"\n        Extract embedded images from DOCX file.\n        \n        Args:\n            doc: python-docx Document object\n            \n        Returns:\n            Dict mapping image IDs to image binary data\n        \"\"\"\n        images = {}\n        \n        try:\n            # Access the document's image parts\n            for rel in doc.part.rels.values():\n                if \"image\" in rel.target_ref:\n                    image_part = rel.target_part\n                    image_id = rel.rId\n                    image_data = image_part.blob\n                    \n                    # Get the image format from the content type\n                    content_type = image_part.content_type\n                    ext = self._get_extension_from_content_type(content_type)\n                    \n                    images[image_id] = {\n                        'data': image_data,\n                        'ext': ext,\n                        'content_type': content_type\n                    }\n        except Exception as e:\n            print(f\"Warning: Could not extract images from DOCX: {str(e)}\")\n            \n        return images\n    \n    def download_image(self, url: str, timeout: int = 10) -> Optional[Tuple[bytes, str]]:\n        \"\"\"\n        Download an image from a URL.\n        \n        Args:\n            url: Image URL\n            timeout: Request timeout in seconds\n            \n        Returns:\n            Tuple of (image_data, extension) or None if download failed\n        \"\"\"\n        try:\n            # Set a user agent to avoid blocks\n            req = urllib.request.Request(\n                url,\n                headers={'User-Agent': 'Mozilla/5.0'}\n            )\n            \n            with urllib.request.urlopen(req, timeout=timeout) as response:\n                image_data = response.read()\n                content_type = response.headers.get('Content-Type', '')\n                ext = self._get_extension_from_content_type(content_type)\n                \n                # If extension not found from content type, try URL\n                if not ext:\n                    ext = self._get_extension_from_url(url)\n                \n                return (image_data, ext)\n                \n        except (urllib.error.URLError, urllib.error.HTTPError, Exception) as e:\n            print(f\"Warning: Could not download image from {url}: {str(e)}\")\n            return None\n    \n    def save_image(self, image_data: bytes, ext: str, prefix: str = \"image\") -> str:\n        \"\"\"\n        Generate a filename for an image and store the mapping.\n        \n        Args:\n            image_data: Binary image data\n            ext: File extension (e.g., 'png', 'jpg')\n            prefix: Filename prefix\n            \n        Returns:\n            Generated filename\n        \"\"\"\n        # Create a hash of the image data to avoid duplicates\n        image_hash = hashlib.md5(image_data).hexdigest()[:8]\n        \n        # Check if we've already saved this image\n        if image_hash in self.images:\n            return self.images[image_hash]\n        \n        # Generate new filename\n        self.image_counter += 1\n        filename = f\"{prefix}_{self.image_counter}_{image_hash}.{ext}\"\n        \n        # Store mapping and data\n        self.images[image_hash] = filename\n        self.image_data[image_hash] = image_data\n        \n        return filename\n    \n    def optimize_image(self, image_data: bytes, max_width: int = 1200, quality: int = 85) -> Tuple[bytes, str]:\n        \"\"\"\n        Optimize an image by resizing and compressing.\n        \n        Args:\n            image_data: Binary image data\n            max_width: Maximum width in pixels\n            quality: JPEG quality (1-100)\n            \n        Returns:\n            Tuple of (optimized_data, extension)\n        \"\"\"\n        try:\n            # Open image\n            img = Image.open(io.BytesIO(image_data))\n            \n            # Convert RGBA to RGB if saving as JPEG\n            if img.mode == 'RGBA':\n                # Create white background\n                background = Image.new('RGB', img.size, (255, 255, 255))\n                background.paste(img, mask=img.split()[3])  # Use alpha channel as mask\n                img = background\n            elif img.mode not in ('RGB', 'L'):\n                img = img.convert('RGB')\n            \n            # Resize if needed\n            if img.width > max_width:\n                ratio = max_width / img.width\n                new_height = int(img.height * ratio)\n                img = img.resize((max_width, new_height), Image.Resampling.LANCZOS)\n            \n            # Save to bytes\n            output = io.BytesIO()\n            img_format = 'JPEG' if img.mode == 'RGB' else 'PNG'\n            img.save(output, format=img_format, quality=quality, optimize=True)\n            \n            ext = 'jpg' if img_format == 'JPEG' else 'png'\n            return (output.getvalue(), ext)\n            \n        except Exception as e:\n            print(f\"Warning: Could not optimize image: {str(e)}\")\n            # Return original data with guessed extension\n            return (image_data, 'png')\n    \n    def _get_extension_from_content_type(self, content_type: str) -> str:\n        \"\"\"Get file extension from MIME content type.\"\"\"\n        content_type_map = {\n            'image/jpeg': 'jpg',\n            'image/jpg': 'jpg',\n            'image/png': 'png',\n            'image/gif': 'gif',\n            'image/webp': 'webp',\n            'image/svg+xml': 'svg',\n            'image/bmp': 'bmp',\n            'image/tiff': 'tiff'\n        }\n        return content_type_map.get(content_type.lower(), 'png')\n    \n    def _get_extension_from_url(self, url: str) -> str:\n        \"\"\"Extract file extension from URL.\"\"\"\n        # Remove query parameters\n        url_path = url.split('?')[0]\n        \n        # Get extension\n        if '.' in url_path:\n            ext = url_path.split('.')[-1].lower()\n            if ext in ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp']:\n                return 'jpg' if ext == 'jpeg' else ext\n        \n        return 'jpg'  # Default\n    \n    def get_all_images(self) -> Dict[str, str]:\n        \"\"\"Get all image mappings.\"\"\"\n        return self.images.copy()\n    \n    def reset(self):\n        \"\"\"Reset the image handler state.\"\"\"\n        self.images = {}\n        self.image_data = {}\n        self.image_counter = 0\n","size_bytes":6847},"utils/seo_validator.py":{"content":"from bs4 import BeautifulSoup\nimport re\nfrom typing import Dict, List, Tuple\nfrom urllib.parse import urlparse\n\nclass SEOValidator:\n    \"\"\"Validate and score HTML content for SEO best practices.\"\"\"\n    \n    def __init__(self):\n        self.issues = []\n        self.warnings = []\n        self.successes = []\n        self.score = 100\n        \n    def validate(self, html_content: str, title: str = None) -> Dict:\n        \"\"\"\n        Validate HTML content for SEO best practices.\n        \n        Args:\n            html_content: HTML string to validate\n            title: Optional title for context\n            \n        Returns:\n            Dict with score, issues, warnings, and recommendations\n        \"\"\"\n        self.issues = []\n        self.warnings = []\n        self.successes = []\n        self.score = 100\n        \n        soup = BeautifulSoup(html_content, 'html.parser')\n        \n        # Run all validation checks\n        self._check_title_tag(soup)\n        self._check_meta_description(soup)\n        self._check_heading_structure(soup)\n        self._check_images(soup)\n        self._check_links(soup)\n        self._check_content_length(soup)\n        self._check_open_graph(soup)\n        self._check_structured_data(soup)\n        self._check_semantic_html(soup)\n        \n        return {\n            'score': max(0, self.score),\n            'issues': self.issues,\n            'warnings': self.warnings,\n            'successes': self.successes,\n            'recommendations': self._generate_recommendations()\n        }\n    \n    def _check_title_tag(self, soup):\n        \"\"\"Check title tag presence and quality.\"\"\"\n        title = soup.find('title')\n        \n        if not title:\n            self.issues.append(\"Missing <title> tag\")\n            self.score -= 15\n        elif not title.string or not title.string.strip():\n            self.issues.append(\"Empty <title> tag\")\n            self.score -= 15\n        else:\n            title_text = title.string.strip()\n            title_length = len(title_text)\n            \n            if title_length < 30:\n                self.warnings.append(f\"Title too short ({title_length} chars, recommend 30-60)\")\n                self.score -= 5\n            elif title_length > 60:\n                self.warnings.append(f\"Title too long ({title_length} chars, recommend 30-60)\")\n                self.score -= 3\n            else:\n                self.successes.append(f\"Title length is optimal ({title_length} chars)\")\n    \n    def _check_meta_description(self, soup):\n        \"\"\"Check meta description presence and quality.\"\"\"\n        meta_desc = soup.find('meta', {'name': 'description'})\n        \n        if not meta_desc or not meta_desc.get('content'):\n            self.issues.append(\"Missing meta description\")\n            self.score -= 10\n        else:\n            desc_text = meta_desc.get('content', '').strip()\n            desc_length = len(desc_text)\n            \n            if desc_length < 50:\n                self.warnings.append(f\"Meta description too short ({desc_length} chars, recommend 120-160)\")\n                self.score -= 5\n            elif desc_length > 160:\n                self.warnings.append(f\"Meta description too long ({desc_length} chars, recommend 120-160)\")\n                self.score -= 3\n            else:\n                self.successes.append(f\"Meta description length is optimal ({desc_length} chars)\")\n    \n    def _check_heading_structure(self, soup):\n        \"\"\"Check heading hierarchy and structure.\"\"\"\n        h1_tags = soup.find_all('h1')\n        \n        if len(h1_tags) == 0:\n            self.issues.append(\"No H1 heading found\")\n            self.score -= 10\n        elif len(h1_tags) > 1:\n            self.warnings.append(f\"Multiple H1 tags found ({len(h1_tags)}), should have only one\")\n            self.score -= 5\n        else:\n            h1_text = h1_tags[0].get_text().strip()\n            if len(h1_text) < 20:\n                self.warnings.append(f\"H1 is short ({len(h1_text)} chars)\")\n                self.score -= 2\n            else:\n                self.successes.append(\"H1 heading is properly structured\")\n        \n        # Check heading hierarchy\n        headings = []\n        for level in range(1, 7):\n            tags = soup.find_all(f'h{level}')\n            for tag in tags:\n                headings.append((level, tag.get_text().strip()))\n        \n        # Verify no heading levels are skipped\n        if headings:\n            prev_level = 0\n            for level, text in headings:\n                if level > prev_level + 1 and prev_level > 0:\n                    self.warnings.append(f\"Heading hierarchy skips level (H{prev_level} to H{level})\")\n                    self.score -= 2\n                    break\n                prev_level = level\n    \n    def _check_images(self, soup):\n        \"\"\"Check images for alt text and optimization.\"\"\"\n        images = soup.find_all('img')\n        \n        if not images:\n            return\n        \n        missing_alt = 0\n        empty_alt = 0\n        good_alt = 0\n        \n        for img in images:\n            alt = img.get('alt')\n            if alt is None:\n                missing_alt += 1\n            elif not alt.strip():\n                empty_alt += 1\n            elif len(alt.strip()) < 5:\n                empty_alt += 1\n            else:\n                good_alt += 1\n        \n        if missing_alt > 0:\n            self.issues.append(f\"{missing_alt} image(s) missing alt text\")\n            self.score -= min(10, missing_alt * 2)\n        \n        if empty_alt > 0:\n            self.warnings.append(f\"{empty_alt} image(s) with empty or very short alt text\")\n            self.score -= min(5, empty_alt)\n        \n        if good_alt > 0:\n            self.successes.append(f\"{good_alt} image(s) have proper alt text\")\n    \n    def _check_links(self, soup):\n        \"\"\"Check internal and external links.\"\"\"\n        links = soup.find_all('a', href=True)\n        \n        if not links:\n            self.warnings.append(\"No links found in content\")\n            self.score -= 3\n            return\n        \n        internal_links = 0\n        external_links = 0\n        broken_links = 0\n        \n        for link in links:\n            href = link.get('href', '')\n            \n            if not href or href.startswith('#'):\n                continue\n            elif href.startswith('http'):\n                external_links += 1\n                # Check if external links have rel=\"noopener\" for security\n                if not link.get('rel'):\n                    self.warnings.append(\"External links should have rel='noopener' or rel='nofollow'\")\n                    self.score -= 1\n            else:\n                internal_links += 1\n        \n        if external_links > 0:\n            self.successes.append(f\"Found {external_links} external link(s)\")\n        if internal_links > 0:\n            self.successes.append(f\"Found {internal_links} internal link(s)\")\n    \n    def _check_content_length(self, soup):\n        \"\"\"Check content length for SEO.\"\"\"\n        # Extract text content\n        text = soup.get_text()\n        words = len(text.split())\n        \n        if words < 300:\n            self.warnings.append(f\"Content is short ({words} words, recommend 300+)\")\n            self.score -= 5\n        elif words > 2000:\n            self.successes.append(f\"Good content length ({words} words)\")\n        else:\n            self.successes.append(f\"Adequate content length ({words} words)\")\n    \n    def _check_open_graph(self, soup):\n        \"\"\"Check Open Graph tags for social sharing.\"\"\"\n        og_tags = {\n            'og:title': soup.find('meta', property='og:title'),\n            'og:description': soup.find('meta', property='og:description'),\n            'og:image': soup.find('meta', property='og:image'),\n            'og:url': soup.find('meta', property='og:url'),\n            'og:type': soup.find('meta', property='og:type')\n        }\n        \n        missing_og = [tag for tag, element in og_tags.items() if not element]\n        \n        if len(missing_og) == 5:\n            self.warnings.append(\"No Open Graph tags found (important for social sharing)\")\n            self.score -= 5\n        elif missing_og:\n            self.warnings.append(f\"Missing Open Graph tags: {', '.join(missing_og)}\")\n            self.score -= 2\n        else:\n            self.successes.append(\"All essential Open Graph tags present\")\n    \n    def _check_structured_data(self, soup):\n        \"\"\"Check for structured data (Schema.org).\"\"\"\n        json_ld = soup.find_all('script', type='application/ld+json')\n        microdata = soup.find_all(attrs={'itemscope': True})\n        \n        if not json_ld and not microdata:\n            self.warnings.append(\"No structured data (Schema.org) found\")\n            self.score -= 3\n        else:\n            self.successes.append(\"Structured data present\")\n    \n    def _check_semantic_html(self, soup):\n        \"\"\"Check for semantic HTML5 elements.\"\"\"\n        semantic_tags = ['article', 'section', 'nav', 'aside', 'header', 'footer', 'main']\n        found_tags = [tag for tag in semantic_tags if soup.find(tag)]\n        \n        if len(found_tags) == 0:\n            self.warnings.append(\"No semantic HTML5 tags found (article, section, etc.)\")\n            self.score -= 3\n        else:\n            self.successes.append(f\"Using semantic HTML5 tags: {', '.join(found_tags)}\")\n    \n    def _generate_recommendations(self) -> List[str]:\n        \"\"\"Generate actionable recommendations based on issues.\"\"\"\n        recommendations = []\n        \n        if any(\"title\" in issue.lower() for issue in self.issues):\n            recommendations.append(\"Add a descriptive title tag (30-60 characters)\")\n        \n        if any(\"meta description\" in issue.lower() for issue in self.issues):\n            recommendations.append(\"Add a meta description (120-160 characters)\")\n        \n        if any(\"H1\" in str(self.issues) for issue in self.issues):\n            recommendations.append(\"Add a single H1 heading to the page\")\n        \n        if any(\"alt text\" in issue.lower() for issue in self.issues):\n            recommendations.append(\"Add descriptive alt text to all images\")\n        \n        if any(\"Open Graph\" in str(self.warnings) for warning in self.warnings):\n            recommendations.append(\"Add Open Graph tags for better social media sharing\")\n        \n        if any(\"structured data\" in warning.lower() for warning in self.warnings):\n            recommendations.append(\"Add Schema.org structured data for rich snippets\")\n        \n        if any(\"semantic\" in warning.lower() for warning in self.warnings):\n            recommendations.append(\"Use semantic HTML5 tags (article, section, header, etc.)\")\n        \n        return recommendations\n\ndef get_seo_grade(score: int) -> str:\n    \"\"\"Convert SEO score to letter grade.\"\"\"\n    if score >= 90:\n        return \"A\"\n    elif score >= 80:\n        return \"B\"\n    elif score >= 70:\n        return \"C\"\n    elif score >= 60:\n        return \"D\"\n    else:\n        return \"F\"\n","size_bytes":11001},"utils/seo_enhancer.py":{"content":"from bs4 import BeautifulSoup\nimport json\nfrom datetime import datetime\nfrom typing import Dict, Optional, List\n\nclass SEOEnhancer:\n    \"\"\"Enhance HTML content with SEO optimizations.\"\"\"\n    \n    def __init__(self):\n        self.base_url = \"\"\n        \n    def enhance(self, html_content: str, title: str, description: str = None, \n                keywords: List[str] = None, author: str = None, \n                canonical_url: str = None) -> str:\n        \"\"\"\n        Enhance HTML content with SEO optimizations.\n        \n        Args:\n            html_content: Original HTML content\n            title: Page title\n            description: Meta description\n            keywords: List of keywords\n            author: Author name\n            canonical_url: Canonical URL\n            \n        Returns:\n            Enhanced HTML content\n        \"\"\"\n        soup = BeautifulSoup(html_content, 'html.parser')\n        \n        # Enhance head section\n        self._enhance_meta_tags(soup, title, description, keywords, author, canonical_url)\n        self._add_open_graph_tags(soup, title, description, canonical_url)\n        self._add_twitter_cards(soup, title, description)\n        self._add_structured_data(soup, title, description, author)\n        \n        # Enhance body content\n        self._ensure_semantic_html(soup)\n        self._enhance_images(soup)\n        self._enhance_links(soup)\n        \n        return str(soup)\n    \n    def _enhance_meta_tags(self, soup, title, description, keywords, author, canonical_url):\n        \"\"\"Add or enhance meta tags.\"\"\"\n        head = soup.find('head')\n        if not head:\n            head = soup.new_tag('head')\n            if soup.html:\n                soup.html.insert(0, head)\n        \n        # Title\n        if not soup.find('title'):\n            title_tag = soup.new_tag('title')\n            title_tag.string = title\n            head.append(title_tag)\n        \n        # Meta description\n        if description and not soup.find('meta', {'name': 'description'}):\n            meta_desc = soup.new_tag('meta', attrs={'name': 'description', 'content': description})\n            head.append(meta_desc)\n        \n        # Keywords\n        if keywords and not soup.find('meta', {'name': 'keywords'}):\n            meta_keywords = soup.new_tag('meta', attrs={'name': 'keywords', 'content': ', '.join(keywords)})\n            head.append(meta_keywords)\n        \n        # Author\n        if author and not soup.find('meta', {'name': 'author'}):\n            meta_author = soup.new_tag('meta', attrs={'name': 'author', 'content': author})\n            head.append(meta_author)\n        \n        # Viewport\n        if not soup.find('meta', {'name': 'viewport'}):\n            meta_viewport = soup.new_tag('meta', attrs={\n                'name': 'viewport', \n                'content': 'width=device-width, initial-scale=1.0'\n            })\n            head.append(meta_viewport)\n        \n        # Charset\n        if not soup.find('meta', charset=True):\n            meta_charset = soup.new_tag('meta', charset='UTF-8')\n            head.insert(0, meta_charset)\n        \n        # Canonical URL\n        if canonical_url and not soup.find('link', {'rel': 'canonical'}):\n            canonical = soup.new_tag('link', attrs={'rel': 'canonical', 'href': canonical_url})\n            head.append(canonical)\n        \n        # Robots meta\n        if not soup.find('meta', {'name': 'robots'}):\n            meta_robots = soup.new_tag('meta', attrs={'name': 'robots', 'content': 'index, follow'})\n            head.append(meta_robots)\n    \n    def _add_open_graph_tags(self, soup, title, description, url):\n        \"\"\"Add Open Graph tags for social sharing.\"\"\"\n        head = soup.find('head')\n        if not head:\n            return\n        \n        og_tags = {\n            'og:type': 'article',\n            'og:title': title,\n            'og:description': description or title,\n            'og:url': url or '',\n            'og:site_name': title\n        }\n        \n        for property, content in og_tags.items():\n            if content and not soup.find('meta', property=property):\n                og_tag = soup.new_tag('meta', attrs={'property': property, 'content': content})\n                head.append(og_tag)\n    \n    def _add_twitter_cards(self, soup, title, description):\n        \"\"\"Add Twitter Card tags.\"\"\"\n        head = soup.find('head')\n        if not head:\n            return\n        \n        twitter_tags = {\n            'twitter:card': 'summary_large_image',\n            'twitter:title': title,\n            'twitter:description': description or title\n        }\n        \n        for name, content in twitter_tags.items():\n            if content and not soup.find('meta', {'name': name}):\n                twitter_tag = soup.new_tag('meta', attrs={'name': name, 'content': content})\n                head.append(twitter_tag)\n    \n    def _add_structured_data(self, soup, title, description, author):\n        \"\"\"Add Schema.org structured data as JSON-LD.\"\"\"\n        head = soup.find('head')\n        if not head:\n            return\n        \n        # Check if structured data already exists\n        if soup.find('script', type='application/ld+json'):\n            return\n        \n        structured_data = {\n            \"@context\": \"https://schema.org\",\n            \"@type\": \"Article\",\n            \"headline\": title,\n            \"description\": description or title,\n            \"author\": {\n                \"@type\": \"Person\",\n                \"name\": author or \"Unknown\"\n            },\n            \"datePublished\": datetime.now().isoformat(),\n            \"dateModified\": datetime.now().isoformat()\n        }\n        \n        script = soup.new_tag('script', type='application/ld+json')\n        script.string = json.dumps(structured_data, indent=2)\n        head.append(script)\n    \n    def _ensure_semantic_html(self, soup):\n        \"\"\"Wrap content in semantic HTML5 tags if not present.\"\"\"\n        body = soup.find('body')\n        if not body:\n            return\n        \n        # If there's no article tag, wrap main content in one\n        if not soup.find('article'):\n            # Find the main content div or create article wrapper\n            main_content = body.find(['div', 'main'])\n            if main_content and not main_content.find_parent('article'):\n                article = soup.new_tag('article')\n                main_content.wrap(article)\n    \n    def _enhance_images(self, soup):\n        \"\"\"Enhance images with proper attributes.\"\"\"\n        images = soup.find_all('img')\n        \n        for img in images:\n            # Add loading=\"lazy\" for performance\n            if not img.get('loading'):\n                img['loading'] = 'lazy'\n            \n            # Ensure alt text exists (add placeholder if missing)\n            if not img.get('alt'):\n                img['alt'] = 'Image'\n            \n            # Add width and height if missing (helps with CLS)\n            if not img.get('width'):\n                img['width'] = '100%'\n    \n    def _enhance_links(self, soup):\n        \"\"\"Enhance links with proper attributes.\"\"\"\n        links = soup.find_all('a', href=True)\n        \n        for link in links:\n            href = link.get('href', '')\n            \n            # Add rel=\"noopener\" to external links\n            if href.startswith('http'):\n                rel = link.get('rel', [])\n                if isinstance(rel, str):\n                    rel = rel.split()\n                if 'noopener' not in rel:\n                    rel.append('noopener')\n                link['rel'] = ' '.join(rel)\n            \n            # Ensure link text is descriptive (not \"click here\")\n            link_text = link.get_text().strip().lower()\n            if link_text in ['click here', 'here', 'link', 'read more'] and not link.get('aria-label'):\n                link['aria-label'] = f\"Link to {href}\"\n","size_bytes":7838},"replit.md":{"content":"# Overview\n\nThis is a file conversion application that transforms various document formats (DOCX, CSV, TXT, WordPress WXR) into clean Markdown and static HTML. Built with Streamlit, it provides a web interface for batch converting files while preserving formatting, automatically extracting/downloading images, and generating static site generator-compatible frontmatter. The application can produce individual converted files or complete static websites with navigation and customizable styling.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Application Framework\n**Problem**: Need an accessible web interface for file conversion without requiring users to install software locally.\n\n**Solution**: Streamlit-based web application that runs in the browser.\n\n**Rationale**: Streamlit provides rapid development of data applications with minimal frontend code. Users can upload files, configure conversion options, and download results through a simple web UI.\n\n## Converter Architecture\n**Problem**: Different file formats require specialized parsing and conversion logic.\n\n**Solution**: Plugin-based converter system with dedicated converter classes for each file type (DOCX, CSV, TXT, WXR).\n\n**Design Pattern**: Each converter implements a common `convert()` method interface, making it easy to add new file format support. Converters are registered in a dictionary and selected based on file extension.\n\n- **DocxConverter**: Uses python-docx library to parse Word documents, extracting text, formatting, and embedded images\n- **CsvConverter**: Leverages pandas for CSV parsing with automatic encoding detection and markdown table generation\n- **TxtConverter**: Plain text processor with encoding fallback support\n- **WxrConverter**: XML parser for WordPress export files using ElementTree and BeautifulSoup\n\n## Content Processing Pipeline\n**Problem**: Need flexible output supporting multiple formats and use cases.\n\n**Solution**: Multi-stage conversion pipeline: File → Markdown → HTML → Static Site\n\n**Flow**:\n1. File upload and format detection\n2. Conversion to Markdown (base format)\n3. Optional HTML generation from Markdown\n4. Optional static site generation with navigation\n\n## Image Handling\n**Problem**: Embedded and remote images need to be extracted and properly referenced in converted content.\n\n**Solution**: Centralized ImageHandler class that manages image extraction, downloading, optimization, and local storage.\n\n**Implementation**:\n- **DOCX Extraction**: Accesses document relationship parts to extract embedded images with their binary data\n- **WXR Download**: Parses img tags from HTML content and downloads images from URLs\n- **Optimization**: Uses Pillow to resize (max 1200px width) and compress images (85% JPEG quality)\n- **Deduplication**: Content-based MD5 hashing prevents duplicate storage\n- **Path Management**: Images stored with unique filenames in assets/ folder\n- **Archive Integration**: Binary data bundled into ZIP downloads and static sites\n- **Relative Paths**: Static site pages use ../assets/ to correctly reference images from pages/ subdirectory\n\n**Recent Change (2025-10-08)**: Completed full image extraction pipeline with proper path handling for static sites.\n\n## HTML Generation\n**Problem**: Users need visually appealing HTML output with customization options.\n\n**Solution**: Template-based HTML generator with multiple themes and color schemes.\n\n**Components**:\n- **HtmlGenerator**: Converts markdown to HTML using Python-Markdown with extensions (tables, code highlighting, TOC)\n- **TemplateManager**: Provides 4 template styles (modern, minimal, classic, dark) and 5 color schemes\n- Templates use pure CSS for styling without external dependencies\n\n## Static Site Generator Support\n**Problem**: Users may want to import converted content into Jekyll, Hugo, or Astro sites.\n\n**Solution**: Frontmatter generator that creates SSG-compatible metadata headers.\n\n**Implementation**: \n- Extracts metadata from source files (dates, authors, categories)\n- Formats as YAML frontmatter specific to each SSG's conventions\n- Prepends frontmatter to markdown output\n\n## Static Site Generation\n**Problem**: Multiple converted files should be navigable as a cohesive website.\n\n**Solution**: StaticSiteGenerator creates a complete site structure with index page and navigation.\n\n**Output Structure**:\n```\nsite.zip\n├── index.html (listing page)\n├── pages/\n│   ├── document1.html\n│   └── document2.html\n└── assets/\n    ├── style.css\n    └── images/\n```\n\n## SEO Optimization\n**Problem**: Generated HTML pages need search engine optimization for better discoverability and ranking.\n\n**Solution**: Comprehensive SEO validation and enhancement system with automatic meta tag injection and semantic improvements.\n\n**Components**:\n- **SEOValidator**: Analyzes HTML for 8 key SEO factors with scoring (0-100) and grading (A-F)\n- **SEOEnhancer**: Automatically injects missing SEO elements into HTML output\n- **UI Integration**: Toggle control in sidebar, dedicated SEO Report tab showing detailed analysis\n\n**Validation Checks**:\n1. **Title Tags**: Length optimization (30-60 characters)\n2. **Meta Description**: Presence and length (120-160 characters)\n3. **Heading Structure**: H1-H6 hierarchy and proper usage\n4. **Image Alt Text**: Accessibility and SEO coverage\n5. **Link Quality**: Internal/external link presence and attributes\n6. **Content Length**: Minimum 300 words recommended\n7. **Open Graph Tags**: Social media sharing metadata\n8. **Structured Data**: Schema.org JSON-LD markup\n\n**Enhancement Features**:\n- Meta tags (description, keywords, author, viewport, robots)\n- Open Graph protocol tags (og:title, og:description, og:type, og:url)\n- Twitter Card metadata\n- Schema.org structured data (Article format with JSON-LD)\n- Canonical URL links\n- Semantic HTML5 elements (header, main, article, footer)\n- Image lazy loading attributes\n- Link security attributes (rel=\"noopener\" for external links)\n\n**Scoring System**:\n- 90-100: Grade A (🟢) - Excellent SEO\n- 80-89: Grade B (🟡) - Good SEO\n- 70-79: Grade C (🟠) - Fair SEO\n- 60-69: Grade D (🔴) - Poor SEO\n- Below 60: Grade F (⚫) - Critical issues\n\n**User Interface**:\n- Sidebar checkbox: \"Enable SEO enhancements\" (default: enabled)\n- SEO Report tab displays: score metric, letter grade, issues, warnings, successes, recommendations\n- Reports generated per file during HTML conversion\n- Toggle on/off to compare SEO-enhanced vs basic HTML\n\n**Recent Change (2025-10-08)**: Completed SEO optimization system with validation, enhancement, and reporting. E2E tested and verified working correctly.\n\n## File Packaging\n**Problem**: Users need all converted files and assets bundled for easy download.\n\n**Solution**: ZIP file generation that packages markdown, HTML, images, and metadata.\n\n**Implementation**: Uses Python's zipfile module to create in-memory ZIP archives with organized folder structure.\n\n# External Dependencies\n\n## Core Libraries\n- **Streamlit**: Web application framework for the user interface\n- **python-docx**: DOCX file parsing and structure extraction\n- **pandas**: CSV file parsing and data manipulation\n- **markdown**: Markdown to HTML conversion with extensions\n- **BeautifulSoup4**: HTML/XML parsing for WordPress exports\n- **Pillow (PIL)**: Image processing and format conversion\n\n## Data Formats Supported\n- DOCX (Microsoft Word)\n- CSV (Comma-separated values)\n- TXT (Plain text with encoding detection)\n- WXR (WordPress eXtended RSS export format)\n\n## Output Formats\n- Markdown (.md) - Universal format\n- HTML (.html) - Standalone web pages\n- Static sites (ZIP) - Complete website bundles\n\n## Static Site Generators\n- Jekyll (Ruby-based)\n- Hugo (Go-based)\n- Astro (JavaScript-based)\n\nFrontmatter is generated in formats compatible with each platform's conventions.\n\n## Image Processing\n- Supports common formats: PNG, JPEG, GIF, BMP, SVG\n- Extracts embedded images from DOCX files\n- Downloads remote images from URLs in WordPress exports\n- Content-based hashing prevents duplicate storage","size_bytes":8128}},"version":1}